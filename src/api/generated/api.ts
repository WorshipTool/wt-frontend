/* tslint:disable */
/* eslint-disable */
/**
 * WorshipTool API
 * API for WorshipTool app
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {
	AxiosInstance,
	AxiosPromise,
	AxiosRequestConfig as RawAxiosRequestConfig,
} from 'axios'
import globalAxios from 'axios'
import type { Configuration } from './configuration'
// Some imports not used depending on template conditions
// @ts-ignore
import type { RequestArgs } from './base'
import {
	DUMMY_BASE_URL,
	assertParamExists,
	createRequestFunction,
	serializeDataIfNeeded,
	setBearerAuthToObject,
	setSearchParams,
	toPathString,
} from './common'
// @ts-ignore
import { BASE_PATH, BaseAPI, RequiredError, operationServerMap } from './base'

/**
 *
 * @export
 * @interface AddFavouriteInDto
 */
export interface AddFavouriteInDto {
	/**
	 *
	 * @type {string}
	 * @memberof AddFavouriteInDto
	 */
	packGuid: string
}
/**
 *
 * @export
 * @interface AddFileToParseQueueOutDto
 */
export interface AddFileToParseQueueOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof AddFileToParseQueueOutDto
	 */
	id: string
}
/**
 *
 * @export
 * @interface AddMediaToPackInDto
 */
export interface AddMediaToPackInDto {
	/**
	 *
	 * @type {string}
	 * @memberof AddMediaToPackInDto
	 */
	mediaUrl: string
	/**
	 *
	 * @type {string}
	 * @memberof AddMediaToPackInDto
	 */
	packGuid: string
}
/**
 *
 * @export
 * @interface AddNoteToVariantInDto
 */
export interface AddNoteToVariantInDto {
	/**
	 *
	 * @type {string}
	 * @memberof AddNoteToVariantInDto
	 */
	content: string
	/**
	 *
	 * @type {object}
	 * @memberof AddNoteToVariantInDto
	 */
	packGuid: object
}
/**
 *
 * @export
 * @interface AddPackToTeamSelectionInDto
 */
export interface AddPackToTeamSelectionInDto {
	/**
	 *
	 * @type {string}
	 * @memberof AddPackToTeamSelectionInDto
	 */
	packGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof AddPackToTeamSelectionInDto
	 */
	teamGuid: string
}
/**
 *
 * @export
 * @interface AddPermissionToGroupInDto
 */
export interface AddPermissionToGroupInDto {
	/**
	 *
	 * @type {string}
	 * @memberof AddPermissionToGroupInDto
	 */
	groupGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof AddPermissionToGroupInDto
	 */
	permissionGuid: string
}
/**
 *
 * @export
 * @interface AddPermissionToUserInDto
 */
export interface AddPermissionToUserInDto {
	/**
	 *
	 * @type {string}
	 * @memberof AddPermissionToUserInDto
	 */
	userGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof AddPermissionToUserInDto
	 */
	permissionGuid: string
}
/**
 *
 * @export
 * @interface AddTeamMebmerByEmailInDto
 */
export interface AddTeamMebmerByEmailInDto {
	/**
	 *
	 * @type {string}
	 * @memberof AddTeamMebmerByEmailInDto
	 */
	email: string
	/**
	 *
	 * @type {string}
	 * @memberof AddTeamMebmerByEmailInDto
	 */
	teamGuid: string
}
/**
 *
 * @export
 * @interface AddTeamNoteToVariantInDto
 */
export interface AddTeamNoteToVariantInDto {
	/**
	 *
	 * @type {string}
	 * @memberof AddTeamNoteToVariantInDto
	 */
	content: string
	/**
	 *
	 * @type {object}
	 * @memberof AddTeamNoteToVariantInDto
	 */
	packGuid: object
	/**
	 *
	 * @type {string}
	 * @memberof AddTeamNoteToVariantInDto
	 */
	teamGuid: string
}
/**
 *
 * @export
 * @interface AddUserLikeToTranslationInDto
 */
export interface AddUserLikeToTranslationInDto {
	/**
	 *
	 * @type {string}
	 * @memberof AddUserLikeToTranslationInDto
	 */
	packGuid: string
}
/**
 *
 * @export
 * @interface AddVariantToPlaylistInDto
 */
export interface AddVariantToPlaylistInDto {
	/**
	 *
	 * @type {string}
	 * @memberof AddVariantToPlaylistInDto
	 */
	packGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof AddVariantToPlaylistInDto
	 */
	playlist: string
}
/**
 *
 * @export
 * @interface AllTeamNoteData
 */
export interface AllTeamNoteData {
	/**
	 *
	 * @type {string}
	 * @memberof AllTeamNoteData
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof AllTeamNoteData
	 */
	content: string
	/**
	 *
	 * @type {string}
	 * @memberof AllTeamNoteData
	 */
	packGuid: string
}
/**
 *
 * @export
 * @interface AllTeamSubdomainAlias
 */
export interface AllTeamSubdomainAlias {
	/**
	 *
	 * @type {string}
	 * @memberof AllTeamSubdomainAlias
	 */
	teamAlias: string
	/**
	 *
	 * @type {string}
	 * @memberof AllTeamSubdomainAlias
	 */
	subdomain: string
}
/**
 *
 * @export
 * @interface AttachPlaylistToTeamInDto
 */
export interface AttachPlaylistToTeamInDto {
	/**
	 *
	 * @type {string}
	 * @memberof AttachPlaylistToTeamInDto
	 */
	playlistGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof AttachPlaylistToTeamInDto
	 */
	teamGuid: string
}
/**
 *
 * @export
 * @interface BaseUserInfoOutDto
 */
export interface BaseUserInfoOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof BaseUserInfoOutDto
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof BaseUserInfoOutDto
	 */
	firstName: string
	/**
	 *
	 * @type {string}
	 * @memberof BaseUserInfoOutDto
	 */
	lastName: string
	/**
	 *
	 * @type {string}
	 * @memberof BaseUserInfoOutDto
	 */
	email: string
	/**
	 *
	 * @type {number}
	 * @memberof BaseUserInfoOutDto
	 */
	role: BaseUserInfoOutDtoRoleEnum
	/**
	 *
	 * @type {string}
	 * @memberof BaseUserInfoOutDto
	 */
	pictureGuid: string
	/**
	 *
	 * @type {Array<number>}
	 * @memberof BaseUserInfoOutDto
	 */
	loginMethods: Array<BaseUserInfoOutDtoLoginMethodsEnum>
}

export const BaseUserInfoOutDtoRoleEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
	NUMBER_3: 3,
} as const

export type BaseUserInfoOutDtoRoleEnum =
	(typeof BaseUserInfoOutDtoRoleEnum)[keyof typeof BaseUserInfoOutDtoRoleEnum]
export const BaseUserInfoOutDtoLoginMethodsEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
} as const

export type BaseUserInfoOutDtoLoginMethodsEnum =
	(typeof BaseUserInfoOutDtoLoginMethodsEnum)[keyof typeof BaseUserInfoOutDtoLoginMethodsEnum]

/**
 *
 * @export
 * @interface BasicSongDto
 */
export interface BasicSongDto {
	/**
	 *
	 * @type {object}
	 * @memberof BasicSongDto
	 */
	guid: object
	/**
	 *
	 * @type {string}
	 * @memberof BasicSongDto
	 */
	title: string
	/**
	 *
	 * @type {BasicVariantPackDto}
	 * @memberof BasicSongDto
	 */
	original?: BasicVariantPackDto
	/**
	 *
	 * @type {Array<BasicVariantPackDto>}
	 * @memberof BasicSongDto
	 */
	packs: Array<BasicVariantPackDto>
}
/**
 *
 * @export
 * @interface BasicVariantPackDto
 */
export interface BasicVariantPackDto {
	/**
	 *
	 * @type {object}
	 * @memberof BasicVariantPackDto
	 */
	packGuid: object
	/**
	 *
	 * @type {string}
	 * @memberof BasicVariantPackDto
	 */
	packAlias: string
	/**
	 *
	 * @type {string}
	 * @memberof BasicVariantPackDto
	 */
	sheetData: string
	/**
	 *
	 * @type {string}
	 * @memberof BasicVariantPackDto
	 */
	title: string
	/**
	 *
	 * @type {object}
	 * @memberof BasicVariantPackDto
	 */
	songGuid: object
	/**
	 *
	 * @type {boolean}
	 * @memberof BasicVariantPackDto
	 */
	public: boolean
	/**
	 *
	 * @type {number}
	 * @memberof BasicVariantPackDto
	 */
	publishApprovalStatus: BasicVariantPackDtoPublishApprovalStatusEnum
	/**
	 *
	 * @type {string}
	 * @memberof BasicVariantPackDto
	 */
	publishedAt: string | null
	/**
	 *
	 * @type {boolean}
	 * @memberof BasicVariantPackDto
	 */
	verified: boolean
	/**
	 *
	 * @type {number}
	 * @memberof BasicVariantPackDto
	 */
	translationType: BasicVariantPackDtoTranslationTypeEnum
	/**
	 *
	 * @type {number}
	 * @memberof BasicVariantPackDto
	 */
	translationLikes: number
	/**
	 *
	 * @type {object}
	 * @memberof BasicVariantPackDto
	 */
	language: object
	/**
	 *
	 * @type {boolean}
	 * @memberof BasicVariantPackDto
	 */
	ggValidated: boolean
	/**
	 *
	 * @type {string}
	 * @memberof BasicVariantPackDto
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof BasicVariantPackDto
	 */
	updatedAt: string
	/**
	 *
	 * @type {string}
	 * @memberof BasicVariantPackDto
	 */
	createdByGuid: string
	/**
	 *
	 * @type {boolean}
	 * @memberof BasicVariantPackDto
	 */
	createdByLoader: boolean
}

export const BasicVariantPackDtoPublishApprovalStatusEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
	NUMBER_3: 3,
} as const

export type BasicVariantPackDtoPublishApprovalStatusEnum =
	(typeof BasicVariantPackDtoPublishApprovalStatusEnum)[keyof typeof BasicVariantPackDtoPublishApprovalStatusEnum]
export const BasicVariantPackDtoTranslationTypeEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
	NUMBER_3: 3,
} as const

export type BasicVariantPackDtoTranslationTypeEnum =
	(typeof BasicVariantPackDtoTranslationTypeEnum)[keyof typeof BasicVariantPackDtoTranslationTypeEnum]

/**
 *
 * @export
 * @interface CSVLink
 */
export interface CSVLink {
	/**
	 *
	 * @type {string}
	 * @memberof CSVLink
	 */
	guid: string
	/**
	 *
	 * @type {Creator}
	 * @memberof CSVLink
	 */
	creator: Creator
	/**
	 *
	 * @type {number}
	 * @memberof CSVLink
	 */
	type: CSVLinkTypeEnum
	/**
	 *
	 * @type {SongVariant}
	 * @memberof CSVLink
	 */
	variant: SongVariant
}

export const CSVLinkTypeEnum = {
	NUMBER_0: 0,
} as const

export type CSVLinkTypeEnum =
	(typeof CSVLinkTypeEnum)[keyof typeof CSVLinkTypeEnum]

/**
 *
 * @export
 * @interface ChangePasswordInDto
 */
export interface ChangePasswordInDto {
	/**
	 *
	 * @type {string}
	 * @memberof ChangePasswordInDto
	 */
	oldPassword: string
	/**
	 *
	 * @type {string}
	 * @memberof ChangePasswordInDto
	 */
	newPassword: string
}
/**
 *
 * @export
 * @interface ChangeProfilePhotoInDto
 */
export interface ChangeProfilePhotoInDto {
	/**
	 *
	 * @type {string}
	 * @memberof ChangeProfilePhotoInDto
	 */
	pictureGuid: string
}
/**
 *
 * @export
 * @interface ChangeTeamInfoInDto
 */
export interface ChangeTeamInfoInDto {
	/**
	 *
	 * @type {string}
	 * @memberof ChangeTeamInfoInDto
	 */
	teamGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof ChangeTeamInfoInDto
	 */
	teamName?: string
	/**
	 *
	 * @type {string}
	 * @memberof ChangeTeamInfoInDto
	 */
	joinCode?: string
}
/**
 *
 * @export
 * @interface ChangeUserNameInDto
 */
export interface ChangeUserNameInDto {
	/**
	 *
	 * @type {string}
	 * @memberof ChangeUserNameInDto
	 */
	firstName: string
	/**
	 *
	 * @type {string}
	 * @memberof ChangeUserNameInDto
	 */
	lastName: string
}
/**
 *
 * @export
 * @interface CompareInDto
 */
export interface CompareInDto {
	/**
	 *
	 * @type {string}
	 * @memberof CompareInDto
	 */
	packGuid1: string
	/**
	 *
	 * @type {string}
	 * @memberof CompareInDto
	 */
	packGuid2: string
}
/**
 *
 * @export
 * @interface CreateTeamEventInDto
 */
export interface CreateTeamEventInDto {
	/**
	 *
	 * @type {string}
	 * @memberof CreateTeamEventInDto
	 */
	teamGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof CreateTeamEventInDto
	 */
	leaderUserGuid: string
	/**
	 *
	 * @type {Array<string>}
	 * @memberof CreateTeamEventInDto
	 */
	memberUserGuids: Array<string>
	/**
	 *
	 * @type {string}
	 * @memberof CreateTeamEventInDto
	 */
	eventTitle: string
	/**
	 *
	 * @type {string}
	 * @memberof CreateTeamEventInDto
	 */
	eventDescription: string
	/**
	 *
	 * @type {string}
	 * @memberof CreateTeamEventInDto
	 */
	playlistGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof CreateTeamEventInDto
	 */
	eventDate: string
}
/**
 *
 * @export
 * @interface CreateTeamInDto
 */
export interface CreateTeamInDto {
	/**
	 *
	 * @type {string}
	 * @memberof CreateTeamInDto
	 */
	teamName: string
}
/**
 *
 * @export
 * @interface CreateTeamOutDto
 */
export interface CreateTeamOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof CreateTeamOutDto
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof CreateTeamOutDto
	 */
	alias: string
}
/**
 *
 * @export
 * @interface Creator
 */
export interface Creator {
	/**
	 *
	 * @type {string}
	 * @memberof Creator
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof Creator
	 */
	name: string
	/**
	 *
	 * @type {Array<CSVLink>}
	 * @memberof Creator
	 */
	links: Array<CSVLink>
}
/**
 *
 * @export
 * @interface CreatorDTO
 */
export interface CreatorDTO {
	/**
	 *
	 * @type {string}
	 * @memberof CreatorDTO
	 */
	name: string
	/**
	 *
	 * @type {number}
	 * @memberof CreatorDTO
	 */
	type: CreatorDTOTypeEnum
}

export const CreatorDTOTypeEnum = {
	NUMBER_0: 0,
} as const

export type CreatorDTOTypeEnum =
	(typeof CreatorDTOTypeEnum)[keyof typeof CreatorDTOTypeEnum]

/**
 *
 * @export
 * @interface DeleteNoteInDto
 */
export interface DeleteNoteInDto {
	/**
	 *
	 * @type {string}
	 * @memberof DeleteNoteInDto
	 */
	noteGuid: string
}
/**
 *
 * @export
 * @interface DeleteTeamInDto
 */
export interface DeleteTeamInDto {
	/**
	 *
	 * @type {string}
	 * @memberof DeleteTeamInDto
	 */
	teamGuid: string
}
/**
 *
 * @export
 * @interface DeleteTeamNoteInDto
 */
export interface DeleteTeamNoteInDto {
	/**
	 *
	 * @type {string}
	 * @memberof DeleteTeamNoteInDto
	 */
	noteGuid: string
}
/**
 *
 * @export
 * @interface EditItemInDto
 */
export interface EditItemInDto {
	/**
	 *
	 * @type {string}
	 * @memberof EditItemInDto
	 */
	itemGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof EditItemInDto
	 */
	title?: string
	/**
	 *
	 * @type {string}
	 * @memberof EditItemInDto
	 */
	sheetData?: string
}
/**
 *
 * @export
 * @interface EditPayloadInDto
 */
export interface EditPayloadInDto {
	/**
	 *
	 * @type {string}
	 * @memberof EditPayloadInDto
	 */
	teamGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof EditPayloadInDto
	 */
	payload: string
}
/**
 *
 * @export
 * @interface EditTeamEventInDto
 */
export interface EditTeamEventInDto {
	/**
	 *
	 * @type {string}
	 * @memberof EditTeamEventInDto
	 */
	eventGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof EditTeamEventInDto
	 */
	eventTitle: string
	/**
	 *
	 * @type {string}
	 * @memberof EditTeamEventInDto
	 */
	eventDescription: string
	/**
	 *
	 * @type {string}
	 * @memberof EditTeamEventInDto
	 */
	eventDate: string
	/**
	 *
	 * @type {string}
	 * @memberof EditTeamEventInDto
	 */
	playlistGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof EditTeamEventInDto
	 */
	leaderUserGuid: string
	/**
	 *
	 * @type {Array<string>}
	 * @memberof EditTeamEventInDto
	 */
	memberUserGuids: Array<string>
}
/**
 *
 * @export
 * @interface EditVariantOutDto
 */
export interface EditVariantOutDto {
	/**
	 *
	 * @type {SongVariant}
	 * @memberof EditVariantOutDto
	 */
	variant: SongVariant
	/**
	 *
	 * @type {string}
	 * @memberof EditVariantOutDto
	 */
	alias: string
}
/**
 *
 * @export
 * @interface ExtendedVariantPackDto
 */
export interface ExtendedVariantPackDto {
	/**
	 *
	 * @type {object}
	 * @memberof ExtendedVariantPackDto
	 */
	packGuid: object
	/**
	 *
	 * @type {string}
	 * @memberof ExtendedVariantPackDto
	 */
	packAlias: string
	/**
	 *
	 * @type {string}
	 * @memberof ExtendedVariantPackDto
	 */
	sheetData: string
	/**
	 *
	 * @type {string}
	 * @memberof ExtendedVariantPackDto
	 */
	title: string
	/**
	 *
	 * @type {object}
	 * @memberof ExtendedVariantPackDto
	 */
	songGuid: object
	/**
	 *
	 * @type {boolean}
	 * @memberof ExtendedVariantPackDto
	 */
	public: boolean
	/**
	 *
	 * @type {number}
	 * @memberof ExtendedVariantPackDto
	 */
	publishApprovalStatus: ExtendedVariantPackDtoPublishApprovalStatusEnum
	/**
	 *
	 * @type {string}
	 * @memberof ExtendedVariantPackDto
	 */
	publishedAt: string | null
	/**
	 *
	 * @type {boolean}
	 * @memberof ExtendedVariantPackDto
	 */
	verified: boolean
	/**
	 *
	 * @type {number}
	 * @memberof ExtendedVariantPackDto
	 */
	translationType: ExtendedVariantPackDtoTranslationTypeEnum
	/**
	 *
	 * @type {number}
	 * @memberof ExtendedVariantPackDto
	 */
	translationLikes: number
	/**
	 *
	 * @type {object}
	 * @memberof ExtendedVariantPackDto
	 */
	language: object
	/**
	 *
	 * @type {boolean}
	 * @memberof ExtendedVariantPackDto
	 */
	ggValidated: boolean
	/**
	 *
	 * @type {string}
	 * @memberof ExtendedVariantPackDto
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof ExtendedVariantPackDto
	 */
	updatedAt: string
	/**
	 *
	 * @type {string}
	 * @memberof ExtendedVariantPackDto
	 */
	createdByGuid: string
	/**
	 *
	 * @type {boolean}
	 * @memberof ExtendedVariantPackDto
	 */
	createdByLoader: boolean
	/**
	 *
	 * @type {boolean}
	 * @memberof ExtendedVariantPackDto
	 */
	deleted: boolean
	/**
	 *
	 * @type {boolean}
	 * @memberof ExtendedVariantPackDto
	 */
	inFormat: boolean
	/**
	 *
	 * @type {number}
	 * @memberof ExtendedVariantPackDto
	 */
	createdType: ExtendedVariantPackDtoCreatedTypeEnum
	/**
	 *
	 * @type {object}
	 * @memberof ExtendedVariantPackDto
	 */
	createdForPlaylistGuid: object | null
	/**
	 *
	 * @type {Array<SourceDTO>}
	 * @memberof ExtendedVariantPackDto
	 */
	sources: Array<SourceDTO>
}

export const ExtendedVariantPackDtoPublishApprovalStatusEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
	NUMBER_3: 3,
} as const

export type ExtendedVariantPackDtoPublishApprovalStatusEnum =
	(typeof ExtendedVariantPackDtoPublishApprovalStatusEnum)[keyof typeof ExtendedVariantPackDtoPublishApprovalStatusEnum]
export const ExtendedVariantPackDtoTranslationTypeEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
	NUMBER_3: 3,
} as const

export type ExtendedVariantPackDtoTranslationTypeEnum =
	(typeof ExtendedVariantPackDtoTranslationTypeEnum)[keyof typeof ExtendedVariantPackDtoTranslationTypeEnum]
export const ExtendedVariantPackDtoCreatedTypeEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
} as const

export type ExtendedVariantPackDtoCreatedTypeEnum =
	(typeof ExtendedVariantPackDtoCreatedTypeEnum)[keyof typeof ExtendedVariantPackDtoCreatedTypeEnum]

/**
 *
 * @export
 * @interface GeneratedEmbedding
 */
export interface GeneratedEmbedding {
	/**
	 *
	 * @type {string}
	 * @memberof GeneratedEmbedding
	 */
	model: string
	/**
	 *
	 * @type {Array<number>}
	 * @memberof GeneratedEmbedding
	 */
	data: Array<number>
}
/**
 *
 * @export
 * @interface GetAllTeamNotesOutDto
 */
export interface GetAllTeamNotesOutDto {
	/**
	 *
	 * @type {Array<AllTeamNoteData>}
	 * @memberof GetAllTeamNotesOutDto
	 */
	notes: Array<AllTeamNoteData>
}
/**
 *
 * @export
 * @interface GetAllTeamSubdomainAliasesOutDto
 */
export interface GetAllTeamSubdomainAliasesOutDto {
	/**
	 *
	 * @type {Array<AllTeamSubdomainAlias>}
	 * @memberof GetAllTeamSubdomainAliasesOutDto
	 */
	aliases: Array<AllTeamSubdomainAlias>
}
/**
 *
 * @export
 * @interface GetBridgeServiceDataDto
 */
export interface GetBridgeServiceDataDto {
	/**
	 *
	 * @type {string}
	 * @memberof GetBridgeServiceDataDto
	 */
	url: string
}
/**
 *
 * @export
 * @interface GetCreatorAutoCompleteItemDto
 */
export interface GetCreatorAutoCompleteItemDto {
	/**
	 *
	 * @type {string}
	 * @memberof GetCreatorAutoCompleteItemDto
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof GetCreatorAutoCompleteItemDto
	 */
	guid: string
}
/**
 *
 * @export
 * @interface GetEmbeddingFromPackOutDto
 */
export interface GetEmbeddingFromPackOutDto {
	/**
	 *
	 * @type {GeneratedEmbedding}
	 * @memberof GetEmbeddingFromPackOutDto
	 */
	whole: GeneratedEmbedding
	/**
	 *
	 * @type {Array<object>}
	 * @memberof GetEmbeddingFromPackOutDto
	 */
	sections: Array<object>
}
/**
 *
 * @export
 * @interface GetFavouritesItemData
 */
export interface GetFavouritesItemData {
	/**
	 *
	 * @type {string}
	 * @memberof GetFavouritesItemData
	 */
	variantGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof GetFavouritesItemData
	 */
	packGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof GetFavouritesItemData
	 */
	teamName?: string
	/**
	 *
	 * @type {string}
	 * @memberof GetFavouritesItemData
	 */
	teamAlias?: string
}
/**
 *
 * @export
 * @interface GetFavouritesOutDto
 */
export interface GetFavouritesOutDto {
	/**
	 *
	 * @type {Array<GetFavouritesItemData>}
	 * @memberof GetFavouritesOutDto
	 */
	items: Array<GetFavouritesItemData>
	/**
	 *
	 * @type {string}
	 * @memberof GetFavouritesOutDto
	 */
	selectionGuid: string
}
/**
 *
 * @export
 * @interface GetGlobalSongsOutDto
 */
export interface GetGlobalSongsOutDto {
	/**
	 *
	 * @type {Array<BasicVariantPackDto>}
	 * @memberof GetGlobalSongsOutDto
	 */
	variants: Array<BasicVariantPackDto>
}
/**
 *
 * @export
 * @interface GetJoinCodeOutDto
 */
export interface GetJoinCodeOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof GetJoinCodeOutDto
	 */
	joinCode: string
}
/**
 *
 * @export
 * @interface GetListSongData
 */
export interface GetListSongData {
	/**
	 *
	 * @type {BasicVariantPackDto}
	 * @memberof GetListSongData
	 */
	original?: BasicVariantPackDto
	/**
	 *
	 * @type {BasicVariantPackDto}
	 * @memberof GetListSongData
	 */
	main: BasicVariantPackDto
}
/**
 *
 * @export
 * @interface GetNotesOfVariantOutDto
 */
export interface GetNotesOfVariantOutDto {
	/**
	 *
	 * @type {Array<NoteData>}
	 * @memberof GetNotesOfVariantOutDto
	 */
	notes: Array<NoteData>
}
/**
 *
 * @export
 * @interface GetOrCreatePermissionInDto
 */
export interface GetOrCreatePermissionInDto {
	/**
	 *
	 * @type {string}
	 * @memberof GetOrCreatePermissionInDto
	 */
	type: string
	/**
	 *
	 * @type {string}
	 * @memberof GetOrCreatePermissionInDto
	 */
	payload?: string
}
/**
 *
 * @export
 * @interface GetPackAliasFromSourceUrlOutDto
 */
export interface GetPackAliasFromSourceUrlOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof GetPackAliasFromSourceUrlOutDto
	 */
	alias: string
	/**
	 *
	 * @type {string}
	 * @memberof GetPackAliasFromSourceUrlOutDto
	 */
	packGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof GetPackAliasFromSourceUrlOutDto
	 */
	title: string
}
/**
 *
 * @export
 * @interface GetPinnedPlaylistsToTeamOutDto
 */
export interface GetPinnedPlaylistsToTeamOutDto {
	/**
	 *
	 * @type {Array<TeamPlaylistData>}
	 * @memberof GetPinnedPlaylistsToTeamOutDto
	 */
	playlists: Array<TeamPlaylistData>
}
/**
 *
 * @export
 * @interface GetPlaylistsResult
 */
export interface GetPlaylistsResult {
	/**
	 *
	 * @type {Array<PlaylistData>}
	 * @memberof GetPlaylistsResult
	 */
	playlists: Array<PlaylistData>
}
/**
 *
 * @export
 * @interface GetRandomVariantOutDto
 */
export interface GetRandomVariantOutDto {
	/**
	 *
	 * @type {BasicVariantPackDto}
	 * @memberof GetRandomVariantOutDto
	 */
	variant: BasicVariantPackDto
}
/**
 *
 * @export
 * @interface GetRecommendedSongsOutDto
 */
export interface GetRecommendedSongsOutDto {
	/**
	 *
	 * @type {Array<BasicVariantPackDto>}
	 * @memberof GetRecommendedSongsOutDto
	 */
	variants: Array<BasicVariantPackDto>
}
/**
 *
 * @export
 * @interface GetSearchInPlaylistResult
 */
export interface GetSearchInPlaylistResult {
	/**
	 *
	 * @type {string}
	 * @memberof GetSearchInPlaylistResult
	 */
	guid: string
	/**
	 *
	 * @type {Array<PlaylistItemOutDto>}
	 * @memberof GetSearchInPlaylistResult
	 */
	items: Array<PlaylistItemOutDto>
}
/**
 *
 * @export
 * @interface GetSongDataOutDto
 */
export interface GetSongDataOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof GetSongDataOutDto
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof GetSongDataOutDto
	 */
	mainTitle: string
	/**
	 *
	 * @type {Array<SongDataCreator>}
	 * @memberof GetSongDataOutDto
	 */
	creators: Array<SongDataCreator>
	/**
	 *
	 * @type {Array<SongDataVariant>}
	 * @memberof GetSongDataOutDto
	 */
	variants: Array<SongDataVariant>
	/**
	 *
	 * @type {Array<SongDataMedia>}
	 * @memberof GetSongDataOutDto
	 */
	media: Array<SongDataMedia>
	/**
	 *
	 * @type {Array<string>}
	 * @memberof GetSongDataOutDto
	 */
	tags: Array<string>
}
/**
 *
 * @export
 * @interface GetTeamAliasFromSubdomainOutDto
 */
export interface GetTeamAliasFromSubdomainOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof GetTeamAliasFromSubdomainOutDto
	 */
	alias: string
}
/**
 *
 * @export
 * @interface GetTeamEventsOutDto
 */
export interface GetTeamEventsOutDto {
	/**
	 *
	 * @type {Array<TeamEventData>}
	 * @memberof GetTeamEventsOutDto
	 */
	events: Array<TeamEventData>
}
/**
 *
 * @export
 * @interface GetTeamInfoOutDto
 */
export interface GetTeamInfoOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof GetTeamInfoOutDto
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof GetTeamInfoOutDto
	 */
	alias: string
	/**
	 *
	 * @type {string}
	 * @memberof GetTeamInfoOutDto
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof GetTeamInfoOutDto
	 */
	selectionGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof GetTeamInfoOutDto
	 */
	createdByGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof GetTeamInfoOutDto
	 */
	joinCode: string
	/**
	 *
	 * @type {string}
	 * @memberof GetTeamInfoOutDto
	 */
	logoGuid: string | null
}
/**
 *
 * @export
 * @interface GetTeamMembersOutDto
 */
export interface GetTeamMembersOutDto {
	/**
	 *
	 * @type {Array<TeamMemberDto>}
	 * @memberof GetTeamMembersOutDto
	 */
	members: Array<TeamMemberDto>
}
/**
 *
 * @export
 * @interface GetTeamStatisticsOutDto
 */
export interface GetTeamStatisticsOutDto {
	/**
	 *
	 * @type {Array<LeastPlayedSong>}
	 * @memberof GetTeamStatisticsOutDto
	 */
	leastPlayedSongs: Array<LeastPlayedSong>
	/**
	 *
	 * @type {Array<LeastPlayedSong>}
	 * @memberof GetTeamStatisticsOutDto
	 */
	topPlayedSongs: Array<LeastPlayedSong>
	/**
	 *
	 * @type {Array<TrendingSong>}
	 * @memberof GetTeamStatisticsOutDto
	 */
	mostTrendingSongs: Array<TrendingSong>
	/**
	 *
	 * @type {Array<PlayedCountSong>}
	 * @memberof GetTeamStatisticsOutDto
	 */
	playedCountSongs: Array<PlayedCountSong>
	/**
	 *
	 * @type {Array<MostFavouriteSong>}
	 * @memberof GetTeamStatisticsOutDto
	 */
	mostFavouriteSongs: Array<MostFavouriteSong>
}
/**
 *
 * @export
 * @interface GetTeamsOfUserOutDto
 */
export interface GetTeamsOfUserOutDto {
	/**
	 *
	 * @type {Array<TeamOfUserDto>}
	 * @memberof GetTeamsOfUserOutDto
	 */
	teams: Array<TeamOfUserDto>
}
/**
 *
 * @export
 * @interface GetUserPermissionOutDto
 */
export interface GetUserPermissionOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof GetUserPermissionOutDto
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof GetUserPermissionOutDto
	 */
	type: string
	/**
	 *
	 * @type {string}
	 * @memberof GetUserPermissionOutDto
	 */
	payload?: string
}
/**
 *
 * @export
 * @interface GetUserTranslationLikesOutDto
 */
export interface GetUserTranslationLikesOutDto {
	/**
	 *
	 * @type {Array<TranslationLikeItemOutDto>}
	 * @memberof GetUserTranslationLikesOutDto
	 */
	likes: Array<TranslationLikeItemOutDto>
}
/**
 *
 * @export
 * @interface GetVariantDataOutDto
 */
export interface GetVariantDataOutDto {
	/**
	 *
	 * @type {object}
	 * @memberof GetVariantDataOutDto
	 */
	packGuid: object
	/**
	 *
	 * @type {ExtendedVariantPackDto}
	 * @memberof GetVariantDataOutDto
	 */
	main: ExtendedVariantPackDto
	/**
	 *
	 * @type {Array<BasicVariantPackDto>}
	 * @memberof GetVariantDataOutDto
	 */
	other: Array<BasicVariantPackDto>
	/**
	 *
	 * @type {Array<SongDataMedia>}
	 * @memberof GetVariantDataOutDto
	 */
	media: Array<SongDataMedia>
	/**
	 *
	 * @type {Array<string>}
	 * @memberof GetVariantDataOutDto
	 */
	tags: Array<string>
}
/**
 *
 * @export
 * @interface GetVariantsOfUserOutDto
 */
export interface GetVariantsOfUserOutDto {
	/**
	 *
	 * @type {Array<BasicVariantPackDto>}
	 * @memberof GetVariantsOfUserOutDto
	 */
	variants: Array<BasicVariantPackDto>
}
/**
 *
 * @export
 * @interface Image
 */
export interface Image {
	/**
	 *
	 * @type {string}
	 * @memberof Image
	 */
	guid: string
	/**
	 *
	 * @type {object}
	 * @memberof Image
	 */
	data: object
	/**
	 *
	 * @type {string}
	 * @memberof Image
	 */
	fileName: string
	/**
	 *
	 * @type {string}
	 * @memberof Image
	 */
	mimeType: string
}
/**
 *
 * @export
 * @interface IsUserMemberOfTeamOutDto
 */
export interface IsUserMemberOfTeamOutDto {
	/**
	 *
	 * @type {boolean}
	 * @memberof IsUserMemberOfTeamOutDto
	 */
	isMember: boolean
}
/**
 *
 * @export
 * @interface JoinTeamInDto
 */
export interface JoinTeamInDto {
	/**
	 *
	 * @type {string}
	 * @memberof JoinTeamInDto
	 */
	joinCode: string
}
/**
 *
 * @export
 * @interface JoinTeamOutDto
 */
export interface JoinTeamOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof JoinTeamOutDto
	 */
	teamAlias: string
	/**
	 *
	 * @type {boolean}
	 * @memberof JoinTeamOutDto
	 */
	newMember: boolean
}
/**
 *
 * @export
 * @interface JwtResult
 */
export interface JwtResult {
	/**
	 *
	 * @type {BaseUserInfoOutDto}
	 * @memberof JwtResult
	 */
	user: BaseUserInfoOutDto
	/**
	 *
	 * @type {string}
	 * @memberof JwtResult
	 */
	token: string
}
/**
 *
 * @export
 * @interface LeastPlayedSong
 */
export interface LeastPlayedSong {
	/**
	 *
	 * @type {number}
	 * @memberof LeastPlayedSong
	 */
	playedCount: number
	/**
	 *
	 * @type {Array<StatisticsSongData>}
	 * @memberof LeastPlayedSong
	 */
	songs: Array<StatisticsSongData>
}
/**
 *
 * @export
 * @interface LeaveTeamInDto
 */
export interface LeaveTeamInDto {
	/**
	 *
	 * @type {string}
	 * @memberof LeaveTeamInDto
	 */
	userGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof LeaveTeamInDto
	 */
	teamAlias: string
}
/**
 *
 * @export
 * @interface LoggerBody
 */
export interface LoggerBody {
	/**
	 *
	 * @type {string}
	 * @memberof LoggerBody
	 */
	title?: string
	/**
	 *
	 * @type {string}
	 * @memberof LoggerBody
	 */
	content: string
}
/**
 *
 * @export
 * @interface LoginInputData
 */
export interface LoginInputData {
	/**
	 *
	 * @type {string}
	 * @memberof LoginInputData
	 */
	email: string
	/**
	 *
	 * @type {string}
	 * @memberof LoginInputData
	 */
	password: string
}
/**
 *
 * @export
 * @interface Media
 */
export interface Media {
	/**
	 *
	 * @type {string}
	 * @memberof Media
	 */
	guid: string
	/**
	 *
	 * @type {number}
	 * @memberof Media
	 */
	type: MediaTypeEnum
	/**
	 *
	 * @type {string}
	 * @memberof Media
	 */
	url: string
}

export const MediaTypeEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
} as const

export type MediaTypeEnum = (typeof MediaTypeEnum)[keyof typeof MediaTypeEnum]

/**
 *
 * @export
 * @interface MergeFamiliesInDto
 */
export interface MergeFamiliesInDto {
	/**
	 *
	 * @type {Array<string>}
	 * @memberof MergeFamiliesInDto
	 */
	songGuids: Array<string>
}
/**
 *
 * @export
 * @interface MostFavouriteSong
 */
export interface MostFavouriteSong {
	/**
	 *
	 * @type {StatisticsSongData}
	 * @memberof MostFavouriteSong
	 */
	song: StatisticsSongData
	/**
	 *
	 * @type {number}
	 * @memberof MostFavouriteSong
	 */
	favouriteCount: number
}
/**
 *
 * @export
 * @interface MovePacksToFamilyInDto
 */
export interface MovePacksToFamilyInDto {
	/**
	 *
	 * @type {Array<string>}
	 * @memberof MovePacksToFamilyInDto
	 */
	packGuids: Array<string>
	/**
	 *
	 * @type {string}
	 * @memberof MovePacksToFamilyInDto
	 */
	targetSongGuid?: string
}
/**
 *
 * @export
 * @interface NoteData
 */
export interface NoteData {
	/**
	 *
	 * @type {string}
	 * @memberof NoteData
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof NoteData
	 */
	content: string
}
/**
 *
 * @export
 * @interface ParserSongData
 */
export interface ParserSongData {
	/**
	 *
	 * @type {string}
	 * @memberof ParserSongData
	 */
	title: string
	/**
	 *
	 * @type {string}
	 * @memberof ParserSongData
	 */
	data: string
}
/**
 *
 * @export
 * @interface ParserSongDataResult
 */
export interface ParserSongDataResult {
	/**
	 *
	 * @type {Array<ParserSongData>}
	 * @memberof ParserSongDataResult
	 */
	sheets: Array<ParserSongData>
	/**
	 *
	 * @type {boolean}
	 * @memberof ParserSongDataResult
	 */
	useAi: boolean
}
/**
 *
 * @export
 * @interface Permission
 */
export interface Permission {
	/**
	 *
	 * @type {string}
	 * @memberof Permission
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof Permission
	 */
	type: string
	/**
	 *
	 * @type {string}
	 * @memberof Permission
	 */
	payload?: string
	/**
	 *
	 * @type {Array<User>}
	 * @memberof Permission
	 */
	users: Array<User>
	/**
	 *
	 * @type {Array<PermissionUserGroup>}
	 * @memberof Permission
	 */
	groups: Array<PermissionUserGroup>
}
/**
 *
 * @export
 * @interface PermissionUserBaseOutDto
 */
export interface PermissionUserBaseOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof PermissionUserBaseOutDto
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof PermissionUserBaseOutDto
	 */
	firstName: string
	/**
	 *
	 * @type {string}
	 * @memberof PermissionUserBaseOutDto
	 */
	lastName: string
	/**
	 *
	 * @type {string}
	 * @memberof PermissionUserBaseOutDto
	 */
	email: string
	/**
	 *
	 * @type {number}
	 * @memberof PermissionUserBaseOutDto
	 */
	role: PermissionUserBaseOutDtoRoleEnum
	/**
	 *
	 * @type {string}
	 * @memberof PermissionUserBaseOutDto
	 */
	pictureGuid: string
}

export const PermissionUserBaseOutDtoRoleEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
	NUMBER_3: 3,
} as const

export type PermissionUserBaseOutDtoRoleEnum =
	(typeof PermissionUserBaseOutDtoRoleEnum)[keyof typeof PermissionUserBaseOutDtoRoleEnum]

/**
 *
 * @export
 * @interface PermissionUserGroup
 */
export interface PermissionUserGroup {
	/**
	 *
	 * @type {string}
	 * @memberof PermissionUserGroup
	 */
	guid: string
	/**
	 *
	 * @type {Array<User>}
	 * @memberof PermissionUserGroup
	 */
	users: Array<User>
	/**
	 *
	 * @type {Array<Permission>}
	 * @memberof PermissionUserGroup
	 */
	permissions: Array<Permission>
}
/**
 *
 * @export
 * @interface PinPlaylistToTeamInDto
 */
export interface PinPlaylistToTeamInDto {
	/**
	 *
	 * @type {string}
	 * @memberof PinPlaylistToTeamInDto
	 */
	playlistGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof PinPlaylistToTeamInDto
	 */
	teamGuid: string
}
/**
 *
 * @export
 * @interface PlayedCountSong
 */
export interface PlayedCountSong {
	/**
	 *
	 * @type {StatisticsSongData}
	 * @memberof PlayedCountSong
	 */
	song: StatisticsSongData
	/**
	 *
	 * @type {number}
	 * @memberof PlayedCountSong
	 */
	playedCount: number
}
/**
 *
 * @export
 * @interface Playlist
 */
export interface Playlist {
	/**
	 *
	 * @type {string}
	 * @memberof Playlist
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof Playlist
	 */
	title: string
	/**
	 *
	 * @type {Array<PlaylistItem>}
	 * @memberof Playlist
	 */
	items: Array<PlaylistItem>
	/**
	 *
	 * @type {User}
	 * @memberof Playlist
	 */
	owner: User
	/**
	 *
	 * @type {boolean}
	 * @memberof Playlist
	 */
	isSelection: boolean
	/**
	 *
	 * @type {PermissionUserGroup}
	 * @memberof Playlist
	 */
	editorsPermissionGroup: PermissionUserGroup
	/**
	 *
	 * @type {Team}
	 * @memberof Playlist
	 */
	belongsToTeam: Team
	/**
	 *
	 * @type {string}
	 * @memberof Playlist
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof Playlist
	 */
	updatedAt: string
	/**
	 *
	 * @type {string}
	 * @memberof Playlist
	 */
	openedAt: string
}
/**
 *
 * @export
 * @interface PlaylistComplexEditInDto
 */
export interface PlaylistComplexEditInDto {
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistComplexEditInDto
	 */
	playlistGuid: string
	/**
	 *
	 * @type {Array<PlaylistComplextEditItem>}
	 * @memberof PlaylistComplexEditInDto
	 */
	items: Array<PlaylistComplextEditItem>
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistComplexEditInDto
	 */
	name?: string
}
/**
 *
 * @export
 * @interface PlaylistComplextEditItem
 */
export interface PlaylistComplextEditItem {
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistComplextEditItem
	 */
	packGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistComplextEditItem
	 */
	toneKey: string
	/**
	 *
	 * @type {PlaylistComplextEditItemNewData}
	 * @memberof PlaylistComplextEditItem
	 */
	newData: PlaylistComplextEditItemNewData
}
/**
 *
 * @export
 * @interface PlaylistComplextEditItemNewData
 */
export interface PlaylistComplextEditItemNewData {
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistComplextEditItemNewData
	 */
	title?: string
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistComplextEditItemNewData
	 */
	sheetData?: string
}
/**
 *
 * @export
 * @interface PlaylistData
 */
export interface PlaylistData {
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistData
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistData
	 */
	title: string
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistData
	 */
	teamGuid?: string
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistData
	 */
	teamName?: string
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistData
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistData
	 */
	updatedAt: string
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistData
	 */
	openedAt: string | null
	/**
	 *
	 * @type {number}
	 * @memberof PlaylistData
	 */
	itemsCount: number
}
/**
 *
 * @export
 * @interface PlaylistDataOutDto
 */
export interface PlaylistDataOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistDataOutDto
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistDataOutDto
	 */
	title: string
	/**
	 *
	 * @type {Array<PlaylistItemOutDto>}
	 * @memberof PlaylistDataOutDto
	 */
	items: Array<PlaylistItemOutDto>
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistDataOutDto
	 */
	ownerGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistDataOutDto
	 */
	teamGuid?: string
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistDataOutDto
	 */
	teamAlias?: string
}
/**
 *
 * @export
 * @interface PlaylistItem
 */
export interface PlaylistItem {
	/**
	 *
	 * @type {object}
	 * @memberof PlaylistItem
	 */
	guid: object
	/**
	 *
	 * @type {object}
	 * @memberof PlaylistItem
	 */
	toneKey: object
	/**
	 *
	 * @type {number}
	 * @memberof PlaylistItem
	 */
	order: number
	/**
	 *
	 * @type {SongVariantHistoryPack}
	 * @memberof PlaylistItem
	 */
	variantPack: SongVariantHistoryPack
	/**
	 *
	 * @type {Playlist}
	 * @memberof PlaylistItem
	 */
	playlist: Playlist
}
/**
 *
 * @export
 * @interface PlaylistItemOutDto
 */
export interface PlaylistItemOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistItemOutDto
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof PlaylistItemOutDto
	 */
	toneKey: string
	/**
	 *
	 * @type {number}
	 * @memberof PlaylistItemOutDto
	 */
	order: number
	/**
	 *
	 * @type {BasicVariantPackDto}
	 * @memberof PlaylistItemOutDto
	 */
	pack: BasicVariantPackDto
}
/**
 *
 * @export
 * @interface PostAiRequestInDto
 */
export interface PostAiRequestInDto {
	/**
	 *
	 * @type {string}
	 * @memberof PostAiRequestInDto
	 */
	text: string
}
/**
 *
 * @export
 * @interface PostAiRequestOutDto
 */
export interface PostAiRequestOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof PostAiRequestOutDto
	 */
	outputString: string
}
/**
 *
 * @export
 * @interface PostChangeLanguageInDto
 */
export interface PostChangeLanguageInDto {
	/**
	 *
	 * @type {object}
	 * @memberof PostChangeLanguageInDto
	 */
	packGuid: object
	/**
	 *
	 * @type {string}
	 * @memberof PostChangeLanguageInDto
	 */
	languageString?: string
}
/**
 *
 * @export
 * @interface PostCreateCopyInDto
 */
export interface PostCreateCopyInDto {
	/**
	 *
	 * @type {object}
	 * @memberof PostCreateCopyInDto
	 */
	packGuid: object
}
/**
 *
 * @export
 * @interface PostCreateCopyOutDto
 */
export interface PostCreateCopyOutDto {
	/**
	 *
	 * @type {SongVariant}
	 * @memberof PostCreateCopyOutDto
	 */
	variant: SongVariant
	/**
	 *
	 * @type {string}
	 * @memberof PostCreateCopyOutDto
	 */
	alias: string
}
/**
 *
 * @export
 * @interface PostCreatePlaylistResult
 */
export interface PostCreatePlaylistResult {
	/**
	 *
	 * @type {string}
	 * @memberof PostCreatePlaylistResult
	 */
	guid: string
}
/**
 *
 * @export
 * @interface PostCreateVariantInDto
 */
export interface PostCreateVariantInDto {
	/**
	 *
	 * @type {string}
	 * @memberof PostCreateVariantInDto
	 */
	title: string
	/**
	 *
	 * @type {string}
	 * @memberof PostCreateVariantInDto
	 */
	sheetData: string
	/**
	 *
	 * @type {SongDataSource}
	 * @memberof PostCreateVariantInDto
	 */
	source?: SongDataSource
	/**
	 *
	 * @type {number}
	 * @memberof PostCreateVariantInDto
	 */
	createdType: PostCreateVariantInDtoCreatedTypeEnum
	/**
	 *
	 * @type {string}
	 * @memberof PostCreateVariantInDto
	 */
	language?: string
}

export const PostCreateVariantInDtoCreatedTypeEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
} as const

export type PostCreateVariantInDtoCreatedTypeEnum =
	(typeof PostCreateVariantInDtoCreatedTypeEnum)[keyof typeof PostCreateVariantInDtoCreatedTypeEnum]

/**
 *
 * @export
 * @interface PostCreateVariantOutDto
 */
export interface PostCreateVariantOutDto {
	/**
	 *
	 * @type {SongVariant}
	 * @memberof PostCreateVariantOutDto
	 */
	variant: SongVariant
	/**
	 *
	 * @type {string}
	 * @memberof PostCreateVariantOutDto
	 */
	alias: string
	/**
	 *
	 * @type {object}
	 * @memberof PostCreateVariantOutDto
	 */
	packGuid: object
}
/**
 *
 * @export
 * @interface PostEditVariantInDto
 */
export interface PostEditVariantInDto {
	/**
	 *
	 * @type {string}
	 * @memberof PostEditVariantInDto
	 */
	variantAlias: string
	/**
	 *
	 * @type {string}
	 * @memberof PostEditVariantInDto
	 */
	sheetData?: string
	/**
	 *
	 * @type {string}
	 * @memberof PostEditVariantInDto
	 */
	title?: string
	/**
	 *
	 * @type {number}
	 * @memberof PostEditVariantInDto
	 */
	createdType: PostEditVariantInDtoCreatedTypeEnum
}

export const PostEditVariantInDtoCreatedTypeEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
} as const

export type PostEditVariantInDtoCreatedTypeEnum =
	(typeof PostEditVariantInDtoCreatedTypeEnum)[keyof typeof PostEditVariantInDtoCreatedTypeEnum]

/**
 *
 * @export
 * @interface PostGetKeywordsInDto
 */
export interface PostGetKeywordsInDto {
	/**
	 *
	 * @type {object}
	 * @memberof PostGetKeywordsInDto
	 */
	packGuid: object
}
/**
 *
 * @export
 * @interface PostGoogleLoginBody
 */
export interface PostGoogleLoginBody {
	/**
	 *
	 * @type {string}
	 * @memberof PostGoogleLoginBody
	 */
	userToken: string
	/**
	 *
	 * @type {string}
	 * @memberof PostGoogleLoginBody
	 */
	email: string
	/**
	 *
	 * @type {string}
	 * @memberof PostGoogleLoginBody
	 */
	firstName: string
	/**
	 *
	 * @type {string}
	 * @memberof PostGoogleLoginBody
	 */
	lastName: string
	/**
	 *
	 * @type {string}
	 * @memberof PostGoogleLoginBody
	 */
	picture: string
}
/**
 *
 * @export
 * @interface PostPublishVariantInDto
 */
export interface PostPublishVariantInDto {
	/**
	 *
	 * @type {object}
	 * @memberof PostPublishVariantInDto
	 */
	packGuid: object
}
/**
 *
 * @export
 * @interface PostSendMailFeedbackInDto
 */
export interface PostSendMailFeedbackInDto {
	/**
	 *
	 * @type {string}
	 * @memberof PostSendMailFeedbackInDto
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof PostSendMailFeedbackInDto
	 */
	email: string
	/**
	 *
	 * @type {string}
	 * @memberof PostSendMailFeedbackInDto
	 */
	message: string
}
/**
 *
 * @export
 * @interface PostSendPackToApprovalInDto
 */
export interface PostSendPackToApprovalInDto {
	/**
	 *
	 * @type {object}
	 * @memberof PostSendPackToApprovalInDto
	 */
	packGuid: object
}
/**
 *
 * @export
 * @interface PostSetCreatorsToPackInDto
 */
export interface PostSetCreatorsToPackInDto {
	/**
	 *
	 * @type {string}
	 * @memberof PostSetCreatorsToPackInDto
	 */
	packGuid: string
	/**
	 *
	 * @type {Array<string>}
	 * @memberof PostSetCreatorsToPackInDto
	 */
	creators: Array<string>
}
/**
 *
 * @export
 * @interface PostValidateSheetDataAndTitleInDto
 */
export interface PostValidateSheetDataAndTitleInDto {
	/**
	 *
	 * @type {string}
	 * @memberof PostValidateSheetDataAndTitleInDto
	 */
	sheetData: string
	/**
	 *
	 * @type {string}
	 * @memberof PostValidateSheetDataAndTitleInDto
	 */
	title: string
	/**
	 *
	 * @type {string}
	 * @memberof PostValidateSheetDataAndTitleInDto
	 */
	language?: string
}
/**
 *
 * @export
 * @interface PostVerifyVariantInDto
 */
export interface PostVerifyVariantInDto {
	/**
	 *
	 * @type {object}
	 * @memberof PostVerifyVariantInDto
	 */
	packGuid: object
	/**
	 *
	 * @type {boolean}
	 * @memberof PostVerifyVariantInDto
	 */
	verify: boolean | null
}
/**
 *
 * @export
 * @interface ProgramSongData
 */
export interface ProgramSongData {
	/**
	 *
	 * @type {number}
	 * @memberof ProgramSongData
	 */
	confidence: number
	/**
	 *
	 * @type {string}
	 * @memberof ProgramSongData
	 */
	title: string
	/**
	 *
	 * @type {string}
	 * @memberof ProgramSongData
	 */
	sheetData: string
	/**
	 *
	 * @type {string}
	 * @memberof ProgramSongData
	 */
	url: string
	/**
	 *
	 * @type {number}
	 * @memberof ProgramSongData
	 */
	createdType: ProgramSongDataCreatedTypeEnum
}

export const ProgramSongDataCreatedTypeEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
} as const

export type ProgramSongDataCreatedTypeEnum =
	(typeof ProgramSongDataCreatedTypeEnum)[keyof typeof ProgramSongDataCreatedTypeEnum]

/**
 *
 * @export
 * @interface RemoveFavouriteInDto
 */
export interface RemoveFavouriteInDto {
	/**
	 *
	 * @type {string}
	 * @memberof RemoveFavouriteInDto
	 */
	packGuid: string
}
/**
 *
 * @export
 * @interface RemoveMediaToPackInDto
 */
export interface RemoveMediaToPackInDto {
	/**
	 *
	 * @type {string}
	 * @memberof RemoveMediaToPackInDto
	 */
	mediaGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof RemoveMediaToPackInDto
	 */
	packGuid: string
}
/**
 *
 * @export
 * @interface RemoveTeamLogoInDto
 */
export interface RemoveTeamLogoInDto {
	/**
	 *
	 * @type {string}
	 * @memberof RemoveTeamLogoInDto
	 */
	teamGuid: string
}
/**
 *
 * @export
 * @interface RenamePlaylistInDto
 */
export interface RenamePlaylistInDto {
	/**
	 *
	 * @type {string}
	 * @memberof RenamePlaylistInDto
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof RenamePlaylistInDto
	 */
	title: string
}
/**
 *
 * @export
 * @interface ReorderPlaylistInDto
 */
export interface ReorderPlaylistInDto {
	/**
	 *
	 * @type {string}
	 * @memberof ReorderPlaylistInDto
	 */
	guid: string
	/**
	 *
	 * @type {Array<ReorderPlaylistItem>}
	 * @memberof ReorderPlaylistInDto
	 */
	items: Array<ReorderPlaylistItem>
}
/**
 *
 * @export
 * @interface ReorderPlaylistItem
 */
export interface ReorderPlaylistItem {
	/**
	 *
	 * @type {string}
	 * @memberof ReorderPlaylistItem
	 */
	guid: string
	/**
	 *
	 * @type {number}
	 * @memberof ReorderPlaylistItem
	 */
	order: number
}
/**
 *
 * @export
 * @interface RequireItemEditInDto
 */
export interface RequireItemEditInDto {
	/**
	 *
	 * @type {string}
	 * @memberof RequireItemEditInDto
	 */
	itemGuid: string
}
/**
 *
 * @export
 * @interface RequireItemEditOutDto
 */
export interface RequireItemEditOutDto {
	/**
	 *
	 * @type {boolean}
	 * @memberof RequireItemEditOutDto
	 */
	createdCopy: boolean
	/**
	 *
	 * @type {string}
	 * @memberof RequireItemEditOutDto
	 */
	packAlias: string
}
/**
 *
 * @export
 * @interface ResetPasswordInDto
 */
export interface ResetPasswordInDto {
	/**
	 *
	 * @type {string}
	 * @memberof ResetPasswordInDto
	 */
	newPassword: string
	/**
	 *
	 * @type {string}
	 * @memberof ResetPasswordInDto
	 */
	resetToken: string
}
/**
 *
 * @export
 * @interface SearchSongPacksDto
 */
export interface SearchSongPacksDto {
	/**
	 *
	 * @type {BasicVariantPackDto}
	 * @memberof SearchSongPacksDto
	 */
	original?: BasicVariantPackDto
	/**
	 *
	 * @type {Array<BasicVariantPackDto>}
	 * @memberof SearchSongPacksDto
	 */
	found: Array<BasicVariantPackDto>
	/**
	 *
	 * @type {Array<BasicVariantPackDto>}
	 * @memberof SearchSongPacksDto
	 */
	other?: Array<BasicVariantPackDto>
}
/**
 *
 * @export
 * @interface SetMemberRoleInDto
 */
export interface SetMemberRoleInDto {
	/**
	 *
	 * @type {string}
	 * @memberof SetMemberRoleInDto
	 */
	userGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof SetMemberRoleInDto
	 */
	teamGuid: string
	/**
	 *
	 * @type {number}
	 * @memberof SetMemberRoleInDto
	 */
	role: SetMemberRoleInDtoRoleEnum
}

export const SetMemberRoleInDtoRoleEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
} as const

export type SetMemberRoleInDtoRoleEnum =
	(typeof SetMemberRoleInDtoRoleEnum)[keyof typeof SetMemberRoleInDtoRoleEnum]

/**
 *
 * @export
 * @interface SetPackTranslationTypeInDto
 */
export interface SetPackTranslationTypeInDto {
	/**
	 *
	 * @type {string}
	 * @memberof SetPackTranslationTypeInDto
	 */
	packGuid: string
	/**
	 *
	 * @type {number}
	 * @memberof SetPackTranslationTypeInDto
	 */
	translationType: SetPackTranslationTypeInDtoTranslationTypeEnum
}

export const SetPackTranslationTypeInDtoTranslationTypeEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
	NUMBER_3: 3,
} as const

export type SetPackTranslationTypeInDtoTranslationTypeEnum =
	(typeof SetPackTranslationTypeInDtoTranslationTypeEnum)[keyof typeof SetPackTranslationTypeInDtoTranslationTypeEnum]

/**
 *
 * @export
 * @interface SignUpInDto
 */
export interface SignUpInDto {
	/**
	 *
	 * @type {string}
	 * @memberof SignUpInDto
	 */
	firstName: string
	/**
	 *
	 * @type {string}
	 * @memberof SignUpInDto
	 */
	lastName: string
	/**
	 *
	 * @type {string}
	 * @memberof SignUpInDto
	 */
	email: string
	/**
	 *
	 * @type {string}
	 * @memberof SignUpInDto
	 */
	password: string
}
/**
 *
 * @export
 * @interface Song
 */
export interface Song {
	/**
	 *
	 * @type {string}
	 * @memberof Song
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof Song
	 */
	_mainTitleGuid: string
	/**
	 *
	 * @type {SongTitle}
	 * @memberof Song
	 */
	mainTitle: SongTitle
	/**
	 *
	 * @type {Array<SongVariantHistoryPack>}
	 * @memberof Song
	 */
	variantPacks: Array<SongVariantHistoryPack>
}
/**
 *
 * @export
 * @interface SongDataCreator
 */
export interface SongDataCreator {
	/**
	 *
	 * @type {string}
	 * @memberof SongDataCreator
	 */
	name: string
	/**
	 *
	 * @type {number}
	 * @memberof SongDataCreator
	 */
	type: SongDataCreatorTypeEnum
}

export const SongDataCreatorTypeEnum = {
	NUMBER_0: 0,
} as const

export type SongDataCreatorTypeEnum =
	(typeof SongDataCreatorTypeEnum)[keyof typeof SongDataCreatorTypeEnum]

/**
 *
 * @export
 * @interface SongDataMedia
 */
export interface SongDataMedia {
	/**
	 *
	 * @type {number}
	 * @memberof SongDataMedia
	 */
	type: SongDataMediaTypeEnum
	/**
	 *
	 * @type {string}
	 * @memberof SongDataMedia
	 */
	url: string
	/**
	 *
	 * @type {string}
	 * @memberof SongDataMedia
	 */
	guid: string
}

export const SongDataMediaTypeEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
} as const

export type SongDataMediaTypeEnum =
	(typeof SongDataMediaTypeEnum)[keyof typeof SongDataMediaTypeEnum]

/**
 *
 * @export
 * @interface SongDataSource
 */
export interface SongDataSource {
	/**
	 *
	 * @type {number}
	 * @memberof SongDataSource
	 */
	type: SongDataSourceTypeEnum
	/**
	 *
	 * @type {string}
	 * @memberof SongDataSource
	 */
	value: string
}

export const SongDataSourceTypeEnum = {
	NUMBER_0: 0,
} as const

export type SongDataSourceTypeEnum =
	(typeof SongDataSourceTypeEnum)[keyof typeof SongDataSourceTypeEnum]

/**
 *
 * @export
 * @interface SongDataVariant
 */
export interface SongDataVariant {
	/**
	 *
	 * @type {string}
	 * @memberof SongDataVariant
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof SongDataVariant
	 */
	packGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof SongDataVariant
	 */
	songGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof SongDataVariant
	 */
	prefferedTitle: string
	/**
	 *
	 * @type {Array<string>}
	 * @memberof SongDataVariant
	 */
	titles: Array<string>
	/**
	 *
	 * @type {string}
	 * @memberof SongDataVariant
	 */
	sheetData: string
	/**
	 *
	 * @type {string}
	 * @memberof SongDataVariant
	 */
	sheetText: string
	/**
	 *
	 * @type {boolean}
	 * @memberof SongDataVariant
	 */
	verified: boolean
	/**
	 *
	 * @type {string}
	 * @memberof SongDataVariant
	 */
	createdByGuid: string
	/**
	 *
	 * @type {boolean}
	 * @memberof SongDataVariant
	 */
	createdByLoader: boolean
	/**
	 *
	 * @type {Array<SourceDTO>}
	 * @memberof SongDataVariant
	 */
	sources: Array<SourceDTO>
	/**
	 *
	 * @type {Array<CreatorDTO>}
	 * @memberof SongDataVariant
	 */
	creators: Array<CreatorDTO>
	/**
	 *
	 * @type {boolean}
	 * @memberof SongDataVariant
	 */
	deleted: boolean
	/**
	 *
	 * @type {number}
	 * @memberof SongDataVariant
	 */
	createdType: SongDataVariantCreatedTypeEnum
	/**
	 *
	 * @type {string}
	 * @memberof SongDataVariant
	 */
	alias: string
	/**
	 *
	 * @type {boolean}
	 * @memberof SongDataVariant
	 */
	inFormat: boolean
	/**
	 *
	 * @type {string}
	 * @memberof SongDataVariant
	 */
	language: string
	/**
	 *
	 * @type {boolean}
	 * @memberof SongDataVariant
	 */
	public: boolean
	/**
	 *
	 * @type {Array<string>}
	 * @memberof SongDataVariant
	 */
	tags: Array<string>
	/**
	 *
	 * @type {string}
	 * @memberof SongDataVariant
	 */
	createdForPlaylistGuid: string | null
	/**
	 *
	 * @type {string}
	 * @memberof SongDataVariant
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof SongDataVariant
	 */
	packCreatedAt: string
}

export const SongDataVariantCreatedTypeEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
} as const

export type SongDataVariantCreatedTypeEnum =
	(typeof SongDataVariantCreatedTypeEnum)[keyof typeof SongDataVariantCreatedTypeEnum]

/**
 *
 * @export
 * @interface SongTitle
 */
export interface SongTitle {
	/**
	 *
	 * @type {string}
	 * @memberof SongTitle
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof SongTitle
	 */
	title: string
	/**
	 *
	 * @type {string}
	 * @memberof SongTitle
	 */
	searchValue: string
	/**
	 *
	 * @type {string}
	 * @memberof SongTitle
	 */
	trigrams?: string
	/**
	 *
	 * @type {SongVariant}
	 * @memberof SongTitle
	 */
	variant: SongVariant
}
/**
 *
 * @export
 * @interface SongVariant
 */
export interface SongVariant {
	/**
	 *
	 * @type {string}
	 * @memberof SongVariant
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof SongVariant
	 */
	sheetData: string
	/**
	 *
	 * @type {string}
	 * @memberof SongVariant
	 */
	searchValue: string
	/**
	 *
	 * @type {string}
	 * @memberof SongVariant
	 */
	trigrams?: string
	/**
	 *
	 * @type {object}
	 * @memberof SongVariant
	 */
	toneKey: object
	/**
	 *
	 * @type {number}
	 * @memberof SongVariant
	 */
	type?: SongVariantTypeEnum
	/**
	 *
	 * @type {SongTitle}
	 * @memberof SongVariant
	 */
	prefferedTitle: SongTitle
	/**
	 *
	 * @type {Array<SongTitle>}
	 * @memberof SongVariant
	 */
	titles: Array<SongTitle>
	/**
	 *
	 * @type {User}
	 * @memberof SongVariant
	 */
	createdBy: User
	/**
	 *
	 * @type {Array<CSVLink>}
	 * @memberof SongVariant
	 */
	links: Array<CSVLink>
	/**
	 *
	 * @type {Array<Source>}
	 * @memberof SongVariant
	 */
	sources: Array<Source>
	/**
	 *
	 * @type {Array<Tag>}
	 * @memberof SongVariant
	 */
	tags: Array<Tag>
	/**
	 *
	 * @type {boolean}
	 * @memberof SongVariant
	 */
	tagsGenerated: boolean
	/**
	 *
	 * @type {number}
	 * @memberof SongVariant
	 */
	createdType: SongVariantCreatedTypeEnum
	/**
	 *
	 * @type {Array<SongVariant>}
	 * @memberof SongVariant
	 */
	children: Array<SongVariant>
	/**
	 *
	 * @type {SongVariant}
	 * @memberof SongVariant
	 */
	parent: SongVariant
	/**
	 *
	 * @type {SongVariantHistoryPack}
	 * @memberof SongVariant
	 */
	historyPack: SongVariantHistoryPack
	/**
	 *
	 * @type {boolean}
	 * @memberof SongVariant
	 */
	inFormat: boolean
	/**
	 *
	 * @type {boolean}
	 * @memberof SongVariant
	 */
	verified: boolean
	/**
	 *
	 * @type {string}
	 * @memberof SongVariant
	 */
	language: string
	/**
	 *
	 * @type {boolean}
	 * @memberof SongVariant
	 */
	hasChords: boolean
	/**
	 *
	 * @type {string}
	 * @memberof SongVariant
	 */
	createdAt: string
	/**
	 *
	 * @type {boolean}
	 * @memberof SongVariant
	 */
	isLast: boolean
}

export const SongVariantTypeEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
} as const

export type SongVariantTypeEnum =
	(typeof SongVariantTypeEnum)[keyof typeof SongVariantTypeEnum]
export const SongVariantCreatedTypeEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
} as const

export type SongVariantCreatedTypeEnum =
	(typeof SongVariantCreatedTypeEnum)[keyof typeof SongVariantCreatedTypeEnum]

/**
 *
 * @export
 * @interface SongVariantHistoryPack
 */
export interface SongVariantHistoryPack {
	/**
	 *
	 * @type {string}
	 * @memberof SongVariantHistoryPack
	 */
	guid: string
	/**
	 *
	 * @type {SongVariant}
	 * @memberof SongVariantHistoryPack
	 */
	last: SongVariant
	/**
	 *
	 * @type {Array<SongVariant>}
	 * @memberof SongVariantHistoryPack
	 */
	variants: Array<SongVariant>
	/**
	 *
	 * @type {string}
	 * @memberof SongVariantHistoryPack
	 */
	_songGuid: string
	/**
	 *
	 * @type {Song}
	 * @memberof SongVariantHistoryPack
	 */
	song: Song
	/**
	 *
	 * @type {Array<UrlAlias>}
	 * @memberof SongVariantHistoryPack
	 */
	aliases: Array<UrlAlias>
	/**
	 *
	 * @type {UrlAlias}
	 * @memberof SongVariantHistoryPack
	 */
	alias: UrlAlias
	/**
	 *
	 * @type {boolean}
	 * @memberof SongVariantHistoryPack
	 */
	deleted: boolean
	/**
	 *
	 * @type {number}
	 * @memberof SongVariantHistoryPack
	 */
	translationType: SongVariantHistoryPackTranslationTypeEnum
	/**
	 *
	 * @type {number}
	 * @memberof SongVariantHistoryPack
	 */
	ggFilter: SongVariantHistoryPackGgFilterEnum
	/**
	 *
	 * @type {boolean}
	 * @memberof SongVariantHistoryPack
	 */
	public: boolean
	/**
	 *
	 * @type {number}
	 * @memberof SongVariantHistoryPack
	 */
	publishApprovalStatus: SongVariantHistoryPackPublishApprovalStatusEnum
	/**
	 *
	 * @type {string}
	 * @memberof SongVariantHistoryPack
	 */
	publishedAt: string | null
	/**
	 *
	 * @type {number}
	 * @memberof SongVariantHistoryPack
	 */
	translationLikesCount: number
	/**
	 *
	 * @type {Playlist}
	 * @memberof SongVariantHistoryPack
	 */
	createdForPlaylist: Playlist
	/**
	 *
	 * @type {Array<PlaylistItem>}
	 * @memberof SongVariantHistoryPack
	 */
	playlistItems: Array<PlaylistItem>
	/**
	 *
	 * @type {Array<Media>}
	 * @memberof SongVariantHistoryPack
	 */
	media: Array<Media>
	/**
	 *
	 * @type {string}
	 * @memberof SongVariantHistoryPack
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof SongVariantHistoryPack
	 */
	updatedAt: string
}

export const SongVariantHistoryPackTranslationTypeEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
	NUMBER_3: 3,
} as const

export type SongVariantHistoryPackTranslationTypeEnum =
	(typeof SongVariantHistoryPackTranslationTypeEnum)[keyof typeof SongVariantHistoryPackTranslationTypeEnum]
export const SongVariantHistoryPackGgFilterEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
	NUMBER_3: 3,
	NUMBER_4: 4,
} as const

export type SongVariantHistoryPackGgFilterEnum =
	(typeof SongVariantHistoryPackGgFilterEnum)[keyof typeof SongVariantHistoryPackGgFilterEnum]
export const SongVariantHistoryPackPublishApprovalStatusEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
	NUMBER_3: 3,
} as const

export type SongVariantHistoryPackPublishApprovalStatusEnum =
	(typeof SongVariantHistoryPackPublishApprovalStatusEnum)[keyof typeof SongVariantHistoryPackPublishApprovalStatusEnum]

/**
 *
 * @export
 * @interface Source
 */
export interface Source {
	/**
	 *
	 * @type {string}
	 * @memberof Source
	 */
	guid: string
	/**
	 *
	 * @type {number}
	 * @memberof Source
	 */
	type: SourceTypeEnum
	/**
	 *
	 * @type {string}
	 * @memberof Source
	 */
	value: string
	/**
	 *
	 * @type {SongVariant}
	 * @memberof Source
	 */
	variant: SongVariant
}

export const SourceTypeEnum = {
	NUMBER_0: 0,
} as const

export type SourceTypeEnum =
	(typeof SourceTypeEnum)[keyof typeof SourceTypeEnum]

/**
 *
 * @export
 * @interface SourceDTO
 */
export interface SourceDTO {
	/**
	 *
	 * @type {number}
	 * @memberof SourceDTO
	 */
	type: SourceDTOTypeEnum
	/**
	 *
	 * @type {string}
	 * @memberof SourceDTO
	 */
	value: string
}

export const SourceDTOTypeEnum = {
	NUMBER_0: 0,
} as const

export type SourceDTOTypeEnum =
	(typeof SourceDTOTypeEnum)[keyof typeof SourceDTOTypeEnum]

/**
 *
 * @export
 * @interface StatisticsSongData
 */
export interface StatisticsSongData {
	/**
	 *
	 * @type {string}
	 * @memberof StatisticsSongData
	 */
	title: string
	/**
	 *
	 * @type {string}
	 * @memberof StatisticsSongData
	 */
	packGuid: string
}
/**
 *
 * @export
 * @interface Tag
 */
export interface Tag {
	/**
	 *
	 * @type {string}
	 * @memberof Tag
	 */
	guid: string
	/**
	 *
	 * @type {Array<SongVariant>}
	 * @memberof Tag
	 */
	variants: Array<SongVariant>
	/**
	 *
	 * @type {string}
	 * @memberof Tag
	 */
	value: string
}
/**
 *
 * @export
 * @interface Team
 */
export interface Team {
	/**
	 *
	 * @type {string}
	 * @memberof Team
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof Team
	 */
	alias: string
	/**
	 *
	 * @type {string}
	 * @memberof Team
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof Team
	 */
	joinCode: string
	/**
	 *
	 * @type {Playlist}
	 * @memberof Team
	 */
	selection: Playlist
	/**
	 *
	 * @type {Array<TeamMember>}
	 * @memberof Team
	 */
	members: Array<TeamMember>
	/**
	 *
	 * @type {User}
	 * @memberof Team
	 */
	createdBy: User
	/**
	 *
	 * @type {PermissionUserGroup}
	 * @memberof Team
	 */
	managersPermissionGroup: PermissionUserGroup
	/**
	 *
	 * @type {Array<Playlist>}
	 * @memberof Team
	 */
	playlists: Array<Playlist>
	/**
	 *
	 * @type {Image}
	 * @memberof Team
	 */
	logo: Image
	/**
	 *
	 * @type {Array<Playlist>}
	 * @memberof Team
	 */
	pinnedPlaylists: Array<Playlist>
	/**
	 *
	 * @type {string}
	 * @memberof Team
	 */
	payload: string
}
/**
 *
 * @export
 * @interface TeamEvent
 */
export interface TeamEvent {
	/**
	 *
	 * @type {string}
	 * @memberof TeamEvent
	 */
	guid: string
	/**
	 *
	 * @type {Team}
	 * @memberof TeamEvent
	 */
	team: Team
	/**
	 *
	 * @type {TeamMember}
	 * @memberof TeamEvent
	 */
	leader: TeamMember
	/**
	 *
	 * @type {Array<TeamMember>}
	 * @memberof TeamEvent
	 */
	members: Array<TeamMember>
	/**
	 *
	 * @type {string}
	 * @memberof TeamEvent
	 */
	title: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamEvent
	 */
	description: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamEvent
	 */
	eventDate: string
	/**
	 *
	 * @type {Playlist}
	 * @memberof TeamEvent
	 */
	attachedPlaylist: Playlist
	/**
	 *
	 * @type {string}
	 * @memberof TeamEvent
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamEvent
	 */
	updatedAt: string
}
/**
 *
 * @export
 * @interface TeamEventData
 */
export interface TeamEventData {
	/**
	 *
	 * @type {string}
	 * @memberof TeamEventData
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamEventData
	 */
	title: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamEventData
	 */
	description: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamEventData
	 */
	date: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamEventData
	 */
	teamGuid: string
	/**
	 *
	 * @type {TeamEventMemberData}
	 * @memberof TeamEventData
	 */
	leader: TeamEventMemberData
	/**
	 *
	 * @type {Array<TeamEventMemberData>}
	 * @memberof TeamEventData
	 */
	members: Array<TeamEventMemberData>
	/**
	 *
	 * @type {TeamEventPlaylistData}
	 * @memberof TeamEventData
	 */
	playlist: TeamEventPlaylistData
}
/**
 *
 * @export
 * @interface TeamEventMemberData
 */
export interface TeamEventMemberData {
	/**
	 *
	 * @type {string}
	 * @memberof TeamEventMemberData
	 */
	userGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamEventMemberData
	 */
	firstName: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamEventMemberData
	 */
	lastName: string
}
/**
 *
 * @export
 * @interface TeamEventPlaylistData
 */
export interface TeamEventPlaylistData {
	/**
	 *
	 * @type {string}
	 * @memberof TeamEventPlaylistData
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamEventPlaylistData
	 */
	title: string
}
/**
 *
 * @export
 * @interface TeamMember
 */
export interface TeamMember {
	/**
	 *
	 * @type {string}
	 * @memberof TeamMember
	 */
	guid: string
	/**
	 *
	 * @type {Team}
	 * @memberof TeamMember
	 */
	team: Team
	/**
	 *
	 * @type {User}
	 * @memberof TeamMember
	 */
	user: User
	/**
	 *
	 * @type {number}
	 * @memberof TeamMember
	 */
	role: TeamMemberRoleEnum
}

export const TeamMemberRoleEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
} as const

export type TeamMemberRoleEnum =
	(typeof TeamMemberRoleEnum)[keyof typeof TeamMemberRoleEnum]

/**
 *
 * @export
 * @interface TeamMemberDto
 */
export interface TeamMemberDto {
	/**
	 *
	 * @type {string}
	 * @memberof TeamMemberDto
	 */
	userGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamMemberDto
	 */
	email: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamMemberDto
	 */
	firstName: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamMemberDto
	 */
	lastName: string
	/**
	 *
	 * @type {number}
	 * @memberof TeamMemberDto
	 */
	role: TeamMemberDtoRoleEnum
}

export const TeamMemberDtoRoleEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
} as const

export type TeamMemberDtoRoleEnum =
	(typeof TeamMemberDtoRoleEnum)[keyof typeof TeamMemberDtoRoleEnum]

/**
 *
 * @export
 * @interface TeamOfUserDto
 */
export interface TeamOfUserDto {
	/**
	 *
	 * @type {string}
	 * @memberof TeamOfUserDto
	 */
	alias: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamOfUserDto
	 */
	name: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamOfUserDto
	 */
	logoGuid: string | null
	/**
	 *
	 * @type {string}
	 * @memberof TeamOfUserDto
	 */
	selectionGuid: string
}
/**
 *
 * @export
 * @interface TeamPlaylistData
 */
export interface TeamPlaylistData {
	/**
	 *
	 * @type {string}
	 * @memberof TeamPlaylistData
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof TeamPlaylistData
	 */
	title: string
}
/**
 *
 * @export
 * @interface TrainFamilyMatchDto
 */
export interface TrainFamilyMatchDto {
	/**
	 *
	 * @type {string}
	 * @memberof TrainFamilyMatchDto
	 */
	packGuid1: string
	/**
	 *
	 * @type {string}
	 * @memberof TrainFamilyMatchDto
	 */
	packGuid2: string
	/**
	 *
	 * @type {boolean}
	 * @memberof TrainFamilyMatchDto
	 */
	match: boolean
	/**
	 *
	 * @type {boolean}
	 * @memberof TrainFamilyMatchDto
	 */
	skip_training?: boolean
}
/**
 *
 * @export
 * @interface TranslationLikeItemOutDto
 */
export interface TranslationLikeItemOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof TranslationLikeItemOutDto
	 */
	packGuid: string
}
/**
 *
 * @export
 * @interface TransposePlaylistItemInDto
 */
export interface TransposePlaylistItemInDto {
	/**
	 *
	 * @type {string}
	 * @memberof TransposePlaylistItemInDto
	 */
	packGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof TransposePlaylistItemInDto
	 */
	playlistGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof TransposePlaylistItemInDto
	 */
	key: string
}
/**
 *
 * @export
 * @interface TrendingSong
 */
export interface TrendingSong {
	/**
	 *
	 * @type {StatisticsSongData}
	 * @memberof TrendingSong
	 */
	song: StatisticsSongData
	/**
	 *
	 * @type {number}
	 * @memberof TrendingSong
	 */
	trending: number
}
/**
 *
 * @export
 * @interface UpdateNoteInDto
 */
export interface UpdateNoteInDto {
	/**
	 *
	 * @type {string}
	 * @memberof UpdateNoteInDto
	 */
	noteGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof UpdateNoteInDto
	 */
	content: string
}
/**
 *
 * @export
 * @interface UpdateTeamNoteInDto
 */
export interface UpdateTeamNoteInDto {
	/**
	 *
	 * @type {string}
	 * @memberof UpdateTeamNoteInDto
	 */
	noteGuid: string
	/**
	 *
	 * @type {string}
	 * @memberof UpdateTeamNoteInDto
	 */
	content: string
}
/**
 *
 * @export
 * @interface UploadImageOutDto
 */
export interface UploadImageOutDto {
	/**
	 *
	 * @type {string}
	 * @memberof UploadImageOutDto
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof UploadImageOutDto
	 */
	fileName: string
}
/**
 *
 * @export
 * @interface UrlAlias
 */
export interface UrlAlias {
	/**
	 *
	 * @type {string}
	 * @memberof UrlAlias
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof UrlAlias
	 */
	alias: string
	/**
	 *
	 * @type {number}
	 * @memberof UrlAlias
	 */
	type: UrlAliasTypeEnum
	/**
	 *
	 * @type {SongVariantHistoryPack}
	 * @memberof UrlAlias
	 */
	pack: SongVariantHistoryPack
}

export const UrlAliasTypeEnum = {
	NUMBER_0: 0,
} as const

export type UrlAliasTypeEnum =
	(typeof UrlAliasTypeEnum)[keyof typeof UrlAliasTypeEnum]

/**
 *
 * @export
 * @interface User
 */
export interface User {
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	firstName: string
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	lastName: string
	/**
	 *
	 * @type {string}
	 * @memberof User
	 */
	email: string
	/**
	 *
	 * @type {number}
	 * @memberof User
	 */
	role: UserRoleEnum
	/**
	 *
	 * @type {Array<SongVariant>}
	 * @memberof User
	 */
	variants: Array<SongVariant>
	/**
	 *
	 * @type {Array<Playlist>}
	 * @memberof User
	 */
	playlists: Array<Playlist>
	/**
	 *
	 * @type {Array<Permission>}
	 * @memberof User
	 */
	permissions: Array<Permission>
	/**
	 *
	 * @type {Array<UserToken>}
	 * @memberof User
	 */
	tokens: Array<UserToken>
	/**
	 *
	 * @type {Array<UserToken>}
	 * @memberof User
	 */
	resetTokens: Array<UserToken>
	/**
	 *
	 * @type {Image}
	 * @memberof User
	 */
	picture: Image
	/**
	 *
	 * @type {Playlist}
	 * @memberof User
	 */
	favourites: Playlist
}

export const UserRoleEnum = {
	NUMBER_0: 0,
	NUMBER_1: 1,
	NUMBER_2: 2,
	NUMBER_3: 3,
} as const

export type UserRoleEnum = (typeof UserRoleEnum)[keyof typeof UserRoleEnum]

/**
 *
 * @export
 * @interface UserToken
 */
export interface UserToken {
	/**
	 *
	 * @type {string}
	 * @memberof UserToken
	 */
	guid: string
	/**
	 *
	 * @type {string}
	 * @memberof UserToken
	 */
	token: string
	/**
	 *
	 * @type {string}
	 * @memberof UserToken
	 */
	createdAt: string
	/**
	 *
	 * @type {string}
	 * @memberof UserToken
	 */
	expiresAt: string
	/**
	 *
	 * @type {string}
	 * @memberof UserToken
	 */
	revokedAt: string
	/**
	 *
	 * @type {User}
	 * @memberof UserToken
	 */
	user: User
}
/**
 *
 * @export
 * @interface ValidationResult
 */
export interface ValidationResult {
	/**
	 *
	 * @type {boolean}
	 * @memberof ValidationResult
	 */
	success: boolean
	/**
	 *
	 * @type {object}
	 * @memberof ValidationResult
	 */
	qualities: object
	/**
	 *
	 * @type {string}
	 * @memberof ValidationResult
	 */
	message: string
}

/**
 * AIApi - axios parameter creator
 * @export
 */
export const AIApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {PostAiRequestInDto} postAiRequestInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		makeRequest: async (
			postAiRequestInDto: PostAiRequestInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postAiRequestInDto' is not null or undefined
			assertParamExists('makeRequest', 'postAiRequestInDto', postAiRequestInDto)
			const localVarPath = `/ai/request`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postAiRequestInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * AIApi - functional programming interface
 * @export
 */
export const AIApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = AIApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {PostAiRequestInDto} postAiRequestInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async makeRequest(
			postAiRequestInDto: PostAiRequestInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<PostAiRequestOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.makeRequest(
				postAiRequestInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AIApi.makeRequest']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * AIApi - factory interface
 * @export
 */
export const AIApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = AIApiFp(configuration)
	return {
		/**
		 *
		 * @param {PostAiRequestInDto} postAiRequestInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		makeRequest(
			postAiRequestInDto: PostAiRequestInDto,
			options?: any
		): AxiosPromise<PostAiRequestOutDto> {
			return localVarFp
				.makeRequest(postAiRequestInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * AIApi - object-oriented interface
 * @export
 * @class AIApi
 * @extends {BaseAPI}
 */
export class AIApi extends BaseAPI {
	/**
	 *
	 * @param {PostAiRequestInDto} postAiRequestInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AIApi
	 */
	public makeRequest(
		postAiRequestInDto: PostAiRequestInDto,
		options?: RawAxiosRequestConfig
	) {
		return AIApiFp(this.configuration)
			.makeRequest(postAiRequestInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {ChangePasswordInDto} changePasswordInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		changePassword: async (
			changePasswordInDto: ChangePasswordInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'changePasswordInDto' is not null or undefined
			assertParamExists(
				'changePassword',
				'changePasswordInDto',
				changePasswordInDto
			)
			const localVarPath = `/auth/change-password`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				changePasswordInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {ChangeProfilePhotoInDto} changeProfilePhotoInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		changeProfilePhoto: async (
			changeProfilePhotoInDto: ChangeProfilePhotoInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'changeProfilePhotoInDto' is not null or undefined
			assertParamExists(
				'changeProfilePhoto',
				'changeProfilePhotoInDto',
				changeProfilePhotoInDto
			)
			const localVarPath = `/auth/change-profile-photo`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				changeProfilePhotoInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {ChangeUserNameInDto} changeUserNameInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		changeUserName: async (
			changeUserNameInDto: ChangeUserNameInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'changeUserNameInDto' is not null or undefined
			assertParamExists(
				'changeUserName',
				'changeUserNameInDto',
				changeUserNameInDto
			)
			const localVarPath = `/auth/change-user-name`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				changeUserNameInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkTokenExpiration: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/auth/checktokenexpiration`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} email
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUserGuidFromEmail: async (
			email: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'email' is not null or undefined
			assertParamExists('getUserGuidFromEmail', 'email', email)
			const localVarPath = `/auth/guidfromemail`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (email !== undefined) {
				localVarQueryParameter['email'] = email
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * The function allows the user to log in using email and password.
		 * @summary Logs in the user using email and password.
		 * @param {LoginInputData} loginInputData
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		login: async (
			loginInputData: LoginInputData,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'loginInputData' is not null or undefined
			assertParamExists('login', 'loginInputData', loginInputData)
			const localVarPath = `/auth/login`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				loginInputData,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * The function allows the user to log in using Google.
		 * @summary Logs in the user using Google.
		 * @param {PostGoogleLoginBody} postGoogleLoginBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		loginWithGoogle: async (
			postGoogleLoginBody: PostGoogleLoginBody,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postGoogleLoginBody' is not null or undefined
			assertParamExists(
				'loginWithGoogle',
				'postGoogleLoginBody',
				postGoogleLoginBody
			)
			const localVarPath = `/auth/login/google`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postGoogleLoginBody,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		logout: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/auth/logout`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {ResetPasswordInDto} resetPasswordInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		resetPassword: async (
			resetPasswordInDto: ResetPasswordInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'resetPasswordInDto' is not null or undefined
			assertParamExists(
				'resetPassword',
				'resetPasswordInDto',
				resetPasswordInDto
			)
			const localVarPath = `/auth/reset-password`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				resetPasswordInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} email
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		sendResetToken: async (
			email: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'email' is not null or undefined
			assertParamExists('sendResetToken', 'email', email)
			const localVarPath = `/auth/send-reset-token`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (email !== undefined) {
				localVarQueryParameter['email'] = email
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * The function allows the user to sign up using email and password.
		 * @summary Signs up the user using email and password.
		 * @param {SignUpInDto} signUpInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		signup: async (
			signUpInDto: SignUpInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'signUpInDto' is not null or undefined
			assertParamExists('signup', 'signUpInDto', signUpInDto)
			const localVarPath = `/auth/signup`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				signUpInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
		 * @summary Signs up or logs in the user using Google.
		 * @param {PostGoogleLoginBody} postGoogleLoginBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		signupWithGoogle: async (
			postGoogleLoginBody: PostGoogleLoginBody,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postGoogleLoginBody' is not null or undefined
			assertParamExists(
				'signupWithGoogle',
				'postGoogleLoginBody',
				postGoogleLoginBody
			)
			const localVarPath = `/auth/signup/google`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postGoogleLoginBody,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {ChangePasswordInDto} changePasswordInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async changePassword(
			changePasswordInDto: ChangePasswordInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(
				changePasswordInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AuthApi.changePassword']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {ChangeProfilePhotoInDto} changeProfilePhotoInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async changeProfilePhoto(
			changeProfilePhotoInDto: ChangeProfilePhotoInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.changeProfilePhoto(
					changeProfilePhotoInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AuthApi.changeProfilePhoto']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {ChangeUserNameInDto} changeUserNameInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async changeUserName(
			changeUserNameInDto: ChangeUserNameInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.changeUserName(
				changeUserNameInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AuthApi.changeUserName']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async checkTokenExpiration(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.checkTokenExpiration(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AuthApi.checkTokenExpiration']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} email
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getUserGuidFromEmail(
			email: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getUserGuidFromEmail(email, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AuthApi.getUserGuidFromEmail']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * The function allows the user to log in using email and password.
		 * @summary Logs in the user using email and password.
		 * @param {LoginInputData} loginInputData
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async login(
			loginInputData: LoginInputData,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResult>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.login(
				loginInputData,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * The function allows the user to log in using Google.
		 * @summary Logs in the user using Google.
		 * @param {PostGoogleLoginBody} postGoogleLoginBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async loginWithGoogle(
			postGoogleLoginBody: PostGoogleLoginBody,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResult>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.loginWithGoogle(
				postGoogleLoginBody,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AuthApi.loginWithGoogle']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async logout(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AuthApi.logout']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {ResetPasswordInDto} resetPasswordInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async resetPassword(
			resetPasswordInDto: ResetPasswordInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(
				resetPasswordInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AuthApi.resetPassword']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} email
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async sendResetToken(
			email: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.sendResetToken(
				email,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AuthApi.sendResetToken']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * The function allows the user to sign up using email and password.
		 * @summary Signs up the user using email and password.
		 * @param {SignUpInDto} signUpInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async signup(
			signUpInDto: SignUpInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.signup(
				signUpInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AuthApi.signup']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
		 * @summary Signs up or logs in the user using Google.
		 * @param {PostGoogleLoginBody} postGoogleLoginBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async signupWithGoogle(
			postGoogleLoginBody: PostGoogleLoginBody,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtResult>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.signupWithGoogle(
					postGoogleLoginBody,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['AuthApi.signupWithGoogle']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = AuthApiFp(configuration)
	return {
		/**
		 *
		 * @param {ChangePasswordInDto} changePasswordInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		changePassword(
			changePasswordInDto: ChangePasswordInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.changePassword(changePasswordInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {ChangeProfilePhotoInDto} changeProfilePhotoInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		changeProfilePhoto(
			changeProfilePhotoInDto: ChangeProfilePhotoInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.changeProfilePhoto(changeProfilePhotoInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {ChangeUserNameInDto} changeUserNameInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		changeUserName(
			changeUserNameInDto: ChangeUserNameInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.changeUserName(changeUserNameInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		checkTokenExpiration(options?: any): AxiosPromise<boolean> {
			return localVarFp
				.checkTokenExpiration(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} email
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUserGuidFromEmail(email: string, options?: any): AxiosPromise<string> {
			return localVarFp
				.getUserGuidFromEmail(email, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * The function allows the user to log in using email and password.
		 * @summary Logs in the user using email and password.
		 * @param {LoginInputData} loginInputData
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		login(
			loginInputData: LoginInputData,
			options?: any
		): AxiosPromise<JwtResult> {
			return localVarFp
				.login(loginInputData, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * The function allows the user to log in using Google.
		 * @summary Logs in the user using Google.
		 * @param {PostGoogleLoginBody} postGoogleLoginBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		loginWithGoogle(
			postGoogleLoginBody: PostGoogleLoginBody,
			options?: any
		): AxiosPromise<JwtResult> {
			return localVarFp
				.loginWithGoogle(postGoogleLoginBody, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		logout(options?: any): AxiosPromise<void> {
			return localVarFp
				.logout(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {ResetPasswordInDto} resetPasswordInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		resetPassword(
			resetPasswordInDto: ResetPasswordInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.resetPassword(resetPasswordInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} email
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		sendResetToken(email: string, options?: any): AxiosPromise<void> {
			return localVarFp
				.sendResetToken(email, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * The function allows the user to sign up using email and password.
		 * @summary Signs up the user using email and password.
		 * @param {SignUpInDto} signUpInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		signup(signUpInDto: SignUpInDto, options?: any): AxiosPromise<void> {
			return localVarFp
				.signup(signUpInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
		 * @summary Signs up or logs in the user using Google.
		 * @param {PostGoogleLoginBody} postGoogleLoginBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		signupWithGoogle(
			postGoogleLoginBody: PostGoogleLoginBody,
			options?: any
		): AxiosPromise<JwtResult> {
			return localVarFp
				.signupWithGoogle(postGoogleLoginBody, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
	/**
	 *
	 * @param {ChangePasswordInDto} changePasswordInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public changePassword(
		changePasswordInDto: ChangePasswordInDto,
		options?: RawAxiosRequestConfig
	) {
		return AuthApiFp(this.configuration)
			.changePassword(changePasswordInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {ChangeProfilePhotoInDto} changeProfilePhotoInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public changeProfilePhoto(
		changeProfilePhotoInDto: ChangeProfilePhotoInDto,
		options?: RawAxiosRequestConfig
	) {
		return AuthApiFp(this.configuration)
			.changeProfilePhoto(changeProfilePhotoInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {ChangeUserNameInDto} changeUserNameInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public changeUserName(
		changeUserNameInDto: ChangeUserNameInDto,
		options?: RawAxiosRequestConfig
	) {
		return AuthApiFp(this.configuration)
			.changeUserName(changeUserNameInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public checkTokenExpiration(options?: RawAxiosRequestConfig) {
		return AuthApiFp(this.configuration)
			.checkTokenExpiration(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} email
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public getUserGuidFromEmail(email: string, options?: RawAxiosRequestConfig) {
		return AuthApiFp(this.configuration)
			.getUserGuidFromEmail(email, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * The function allows the user to log in using email and password.
	 * @summary Logs in the user using email and password.
	 * @param {LoginInputData} loginInputData
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public login(
		loginInputData: LoginInputData,
		options?: RawAxiosRequestConfig
	) {
		return AuthApiFp(this.configuration)
			.login(loginInputData, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * The function allows the user to log in using Google.
	 * @summary Logs in the user using Google.
	 * @param {PostGoogleLoginBody} postGoogleLoginBody
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public loginWithGoogle(
		postGoogleLoginBody: PostGoogleLoginBody,
		options?: RawAxiosRequestConfig
	) {
		return AuthApiFp(this.configuration)
			.loginWithGoogle(postGoogleLoginBody, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public logout(options?: RawAxiosRequestConfig) {
		return AuthApiFp(this.configuration)
			.logout(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {ResetPasswordInDto} resetPasswordInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public resetPassword(
		resetPasswordInDto: ResetPasswordInDto,
		options?: RawAxiosRequestConfig
	) {
		return AuthApiFp(this.configuration)
			.resetPassword(resetPasswordInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} email
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public sendResetToken(email: string, options?: RawAxiosRequestConfig) {
		return AuthApiFp(this.configuration)
			.sendResetToken(email, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * The function allows the user to sign up using email and password.
	 * @summary Signs up the user using email and password.
	 * @param {SignUpInDto} signUpInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public signup(signUpInDto: SignUpInDto, options?: RawAxiosRequestConfig) {
		return AuthApiFp(this.configuration)
			.signup(signUpInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * The function allows the user to sign up or log in using Google. If the email is already registered, the google account is linked to the existing account.
	 * @summary Signs up or logs in the user using Google.
	 * @param {PostGoogleLoginBody} postGoogleLoginBody
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof AuthApi
	 */
	public signupWithGoogle(
		postGoogleLoginBody: PostGoogleLoginBody,
		options?: RawAxiosRequestConfig
	) {
		return AuthApiFp(this.configuration)
			.signupWithGoogle(postGoogleLoginBody, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * BridgeApi - axios parameter creator
 * @export
 */
export const BridgeApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} type
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBridgeServiceUrlByType: async (
			type: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'type' is not null or undefined
			assertParamExists('getBridgeServiceUrlByType', 'type', type)
			const localVarPath = `/bridge/service-data/{type}`.replace(
				`{${'type'}}`,
				encodeURIComponent(String(type))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getServices: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/bridge`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {TrainFamilyMatchDto} trainFamilyMatchDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		trainFamilyMatch: async (
			trainFamilyMatchDto: TrainFamilyMatchDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'trainFamilyMatchDto' is not null or undefined
			assertParamExists(
				'trainFamilyMatch',
				'trainFamilyMatchDto',
				trainFamilyMatchDto
			)
			const localVarPath = `/family-matcher/train-family-match`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				trainFamilyMatchDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * BridgeApi - functional programming interface
 * @export
 */
export const BridgeApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = BridgeApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {string} type
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getBridgeServiceUrlByType(
			type: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetBridgeServiceDataDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getBridgeServiceUrlByType(type, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['BridgeApi.getBridgeServiceUrlByType']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getServices(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getServices(
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['BridgeApi.getServices']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {TrainFamilyMatchDto} trainFamilyMatchDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async trainFamilyMatch(
			trainFamilyMatchDto: TrainFamilyMatchDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.trainFamilyMatch(
					trainFamilyMatchDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['BridgeApi.trainFamilyMatch']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * BridgeApi - factory interface
 * @export
 */
export const BridgeApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = BridgeApiFp(configuration)
	return {
		/**
		 *
		 * @param {string} type
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBridgeServiceUrlByType(
			type: string,
			options?: any
		): AxiosPromise<GetBridgeServiceDataDto> {
			return localVarFp
				.getBridgeServiceUrlByType(type, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getServices(options?: any): AxiosPromise<object> {
			return localVarFp
				.getServices(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {TrainFamilyMatchDto} trainFamilyMatchDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		trainFamilyMatch(
			trainFamilyMatchDto: TrainFamilyMatchDto,
			options?: any
		): AxiosPromise<object> {
			return localVarFp
				.trainFamilyMatch(trainFamilyMatchDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * BridgeApi - object-oriented interface
 * @export
 * @class BridgeApi
 * @extends {BaseAPI}
 */
export class BridgeApi extends BaseAPI {
	/**
	 *
	 * @param {string} type
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BridgeApi
	 */
	public getBridgeServiceUrlByType(
		type: string,
		options?: RawAxiosRequestConfig
	) {
		return BridgeApiFp(this.configuration)
			.getBridgeServiceUrlByType(type, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BridgeApi
	 */
	public getServices(options?: RawAxiosRequestConfig) {
		return BridgeApiFp(this.configuration)
			.getServices(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {TrainFamilyMatchDto} trainFamilyMatchDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof BridgeApi
	 */
	public trainFamilyMatch(
		trainFamilyMatchDto: TrainFamilyMatchDto,
		options?: RawAxiosRequestConfig
	) {
		return BridgeApiFp(this.configuration)
			.trainFamilyMatch(trainFamilyMatchDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getHello: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		root: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/monitor/status`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getHello(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getHello(
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['DefaultApi.getHello']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async root(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.root(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['DefaultApi.root']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = DefaultApiFp(configuration)
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getHello(options?: any): AxiosPromise<string> {
			return localVarFp
				.getHello(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		root(options?: any): AxiosPromise<void> {
			return localVarFp
				.root(options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public getHello(options?: RawAxiosRequestConfig) {
		return DefaultApiFp(this.configuration)
			.getHello(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DefaultApi
	 */
	public root(options?: RawAxiosRequestConfig) {
		return DefaultApiFp(this.configuration)
			.root(options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} guid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getImage: async (
			guid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'guid' is not null or undefined
			assertParamExists('getImage', 'guid', guid)
			const localVarPath = `/images/{guid}`.replace(
				`{${'guid'}}`,
				encodeURIComponent(String(guid))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		uploadFile: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/images/upload`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {string} guid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getImage(
			guid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getImage(
				guid,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ImagesApi.getImage']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async uploadFile(
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<UploadImageOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ImagesApi.uploadFile']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = ImagesApiFp(configuration)
	return {
		/**
		 *
		 * @param {string} guid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getImage(guid: string, options?: any): AxiosPromise<object> {
			return localVarFp
				.getImage(guid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		uploadFile(options?: any): AxiosPromise<UploadImageOutDto> {
			return localVarFp
				.uploadFile(options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
	/**
	 *
	 * @param {string} guid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ImagesApi
	 */
	public getImage(guid: string, options?: RawAxiosRequestConfig) {
		return ImagesApiFp(this.configuration)
			.getImage(guid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ImagesApi
	 */
	public uploadFile(options?: RawAxiosRequestConfig) {
		return ImagesApiFp(this.configuration)
			.uploadFile(options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * LoggerApi - axios parameter creator
 * @export
 */
export const LoggerApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {LoggerBody} loggerBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		error: async (
			loggerBody: LoggerBody,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'loggerBody' is not null or undefined
			assertParamExists('error', 'loggerBody', loggerBody)
			const localVarPath = `/error`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				loggerBody,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {LoggerBody} loggerBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		log: async (
			loggerBody: LoggerBody,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'loggerBody' is not null or undefined
			assertParamExists('log', 'loggerBody', loggerBody)
			const localVarPath = `/log`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				loggerBody,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {LoggerBody} loggerBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		warn: async (
			loggerBody: LoggerBody,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'loggerBody' is not null or undefined
			assertParamExists('warn', 'loggerBody', loggerBody)
			const localVarPath = `/warn`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				loggerBody,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * LoggerApi - functional programming interface
 * @export
 */
export const LoggerApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = LoggerApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {LoggerBody} loggerBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async error(
			loggerBody: LoggerBody,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.error(
				loggerBody,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['LoggerApi.error']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {LoggerBody} loggerBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async log(
			loggerBody: LoggerBody,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.log(
				loggerBody,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['LoggerApi.log']?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {LoggerBody} loggerBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async warn(
			loggerBody: LoggerBody,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.warn(
				loggerBody,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['LoggerApi.warn']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * LoggerApi - factory interface
 * @export
 */
export const LoggerApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = LoggerApiFp(configuration)
	return {
		/**
		 *
		 * @param {LoggerBody} loggerBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		error(loggerBody: LoggerBody, options?: any): AxiosPromise<void> {
			return localVarFp
				.error(loggerBody, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {LoggerBody} loggerBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		log(loggerBody: LoggerBody, options?: any): AxiosPromise<void> {
			return localVarFp
				.log(loggerBody, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {LoggerBody} loggerBody
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		warn(loggerBody: LoggerBody, options?: any): AxiosPromise<void> {
			return localVarFp
				.warn(loggerBody, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * LoggerApi - object-oriented interface
 * @export
 * @class LoggerApi
 * @extends {BaseAPI}
 */
export class LoggerApi extends BaseAPI {
	/**
	 *
	 * @param {LoggerBody} loggerBody
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LoggerApi
	 */
	public error(loggerBody: LoggerBody, options?: RawAxiosRequestConfig) {
		return LoggerApiFp(this.configuration)
			.error(loggerBody, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {LoggerBody} loggerBody
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LoggerApi
	 */
	public log(loggerBody: LoggerBody, options?: RawAxiosRequestConfig) {
		return LoggerApiFp(this.configuration)
			.log(loggerBody, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {LoggerBody} loggerBody
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LoggerApi
	 */
	public warn(loggerBody: LoggerBody, options?: RawAxiosRequestConfig) {
		return LoggerApiFp(this.configuration)
			.warn(loggerBody, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * MailApi - axios parameter creator
 * @export
 */
export const MailApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {PostSendMailFeedbackInDto} postSendMailFeedbackInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		sendFeedbackMail: async (
			postSendMailFeedbackInDto: PostSendMailFeedbackInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postSendMailFeedbackInDto' is not null or undefined
			assertParamExists(
				'sendFeedbackMail',
				'postSendMailFeedbackInDto',
				postSendMailFeedbackInDto
			)
			const localVarPath = `/mail/feedback`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postSendMailFeedbackInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * MailApi - functional programming interface
 * @export
 */
export const MailApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = MailApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {PostSendMailFeedbackInDto} postSendMailFeedbackInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async sendFeedbackMail(
			postSendMailFeedbackInDto: PostSendMailFeedbackInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.sendFeedbackMail(
					postSendMailFeedbackInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['MailApi.sendFeedbackMail']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * MailApi - factory interface
 * @export
 */
export const MailApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = MailApiFp(configuration)
	return {
		/**
		 *
		 * @param {PostSendMailFeedbackInDto} postSendMailFeedbackInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		sendFeedbackMail(
			postSendMailFeedbackInDto: PostSendMailFeedbackInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.sendFeedbackMail(postSendMailFeedbackInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * MailApi - object-oriented interface
 * @export
 * @class MailApi
 * @extends {BaseAPI}
 */
export class MailApi extends BaseAPI {
	/**
	 *
	 * @param {PostSendMailFeedbackInDto} postSendMailFeedbackInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof MailApi
	 */
	public sendFeedbackMail(
		postSendMailFeedbackInDto: PostSendMailFeedbackInDto,
		options?: RawAxiosRequestConfig
	) {
		return MailApiFp(this.configuration)
			.sendFeedbackMail(postSendMailFeedbackInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * PackEmbeddingApi - axios parameter creator
 * @export
 */
export const PackEmbeddingApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addAllPacksToGenerate: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/pack-embedding/addAllPacksToGenerate`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addPackToGenerate: async (
			packGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('addPackToGenerate', 'packGuid', packGuid)
			const localVarPath = `/pack-embedding/addpacktogenerate`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (packGuid !== undefined) {
				localVarQueryParameter['packGuid'] = packGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findFamily: async (
			packGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('findFamily', 'packGuid', packGuid)
			const localVarPath = `/pack-embedding/findFamily`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (packGuid !== undefined) {
				localVarQueryParameter['packGuid'] = packGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findSimilarPacks: async (
			packGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('findSimilarPacks', 'packGuid', packGuid)
			const localVarPath = `/pack-embedding/findSimilarPacks`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (packGuid !== undefined) {
				localVarQueryParameter['packGuid'] = packGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPackEmbedding: async (
			packGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('getPackEmbedding', 'packGuid', packGuid)
			const localVarPath = `/pack-embedding/getPackEmbedding`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (packGuid !== undefined) {
				localVarQueryParameter['packGuid'] = packGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} searchKey
		 * @param {number} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		search: async (
			searchKey: string,
			page?: number,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'searchKey' is not null or undefined
			assertParamExists('search', 'searchKey', searchKey)
			const localVarPath = `/pack-embedding/search`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (searchKey !== undefined) {
				localVarQueryParameter['searchKey'] = searchKey
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {string} text
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		testPackVectorize: async (
			packGuid: string,
			text: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('testPackVectorize', 'packGuid', packGuid)
			// verify required parameter 'text' is not null or undefined
			assertParamExists('testPackVectorize', 'text', text)
			const localVarPath = `/pack-embedding/testpack`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (packGuid !== undefined) {
				localVarQueryParameter['packGuid'] = packGuid
			}

			if (text !== undefined) {
				localVarQueryParameter['text'] = text
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} text1
		 * @param {string} text2
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		testVectorize: async (
			text1: string,
			text2: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'text1' is not null or undefined
			assertParamExists('testVectorize', 'text1', text1)
			// verify required parameter 'text2' is not null or undefined
			assertParamExists('testVectorize', 'text2', text2)
			const localVarPath = `/pack-embedding/test`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (text1 !== undefined) {
				localVarQueryParameter['text1'] = text1
			}

			if (text2 !== undefined) {
				localVarQueryParameter['text2'] = text2
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * PackEmbeddingApi - functional programming interface
 * @export
 */
export const PackEmbeddingApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		PackEmbeddingApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addAllPacksToGenerate(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addAllPacksToGenerate(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PackEmbeddingApi.addAllPacksToGenerate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addPackToGenerate(
			packGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addPackToGenerate(packGuid, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PackEmbeddingApi.addPackToGenerate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async findFamily(
			packGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<BasicVariantPackDto>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.findFamily(
				packGuid,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PackEmbeddingApi.findFamily']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async findSimilarPacks(
			packGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<BasicVariantPackDto>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.findSimilarPacks(packGuid, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PackEmbeddingApi.findSimilarPacks']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getPackEmbedding(
			packGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetEmbeddingFromPackOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getPackEmbedding(packGuid, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PackEmbeddingApi.getPackEmbedding']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} searchKey
		 * @param {number} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async search(
			searchKey: string,
			page?: number,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<BasicVariantPackDto>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.search(
				searchKey,
				page,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PackEmbeddingApi.search']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {string} text
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async testPackVectorize(
			packGuid: string,
			text: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.testPackVectorize(
					packGuid,
					text,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PackEmbeddingApi.testPackVectorize']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} text1
		 * @param {string} text2
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async testVectorize(
			text1: string,
			text2: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.testVectorize(
				text1,
				text2,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PackEmbeddingApi.testVectorize']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * PackEmbeddingApi - factory interface
 * @export
 */
export const PackEmbeddingApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = PackEmbeddingApiFp(configuration)
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addAllPacksToGenerate(options?: any): AxiosPromise<Array<string>> {
			return localVarFp
				.addAllPacksToGenerate(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addPackToGenerate(packGuid: string, options?: any): AxiosPromise<string> {
			return localVarFp
				.addPackToGenerate(packGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findFamily(
			packGuid: string,
			options?: any
		): AxiosPromise<Array<BasicVariantPackDto>> {
			return localVarFp
				.findFamily(packGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		findSimilarPacks(
			packGuid: string,
			options?: any
		): AxiosPromise<Array<BasicVariantPackDto>> {
			return localVarFp
				.findSimilarPacks(packGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPackEmbedding(
			packGuid: string,
			options?: any
		): AxiosPromise<GetEmbeddingFromPackOutDto> {
			return localVarFp
				.getPackEmbedding(packGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} searchKey
		 * @param {number} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		search(
			searchKey: string,
			page?: number,
			options?: any
		): AxiosPromise<Array<BasicVariantPackDto>> {
			return localVarFp
				.search(searchKey, page, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {string} text
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		testPackVectorize(
			packGuid: string,
			text: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.testPackVectorize(packGuid, text, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} text1
		 * @param {string} text2
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		testVectorize(
			text1: string,
			text2: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.testVectorize(text1, text2, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * PackEmbeddingApi - object-oriented interface
 * @export
 * @class PackEmbeddingApi
 * @extends {BaseAPI}
 */
export class PackEmbeddingApi extends BaseAPI {
	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PackEmbeddingApi
	 */
	public addAllPacksToGenerate(options?: RawAxiosRequestConfig) {
		return PackEmbeddingApiFp(this.configuration)
			.addAllPacksToGenerate(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} packGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PackEmbeddingApi
	 */
	public addPackToGenerate(packGuid: string, options?: RawAxiosRequestConfig) {
		return PackEmbeddingApiFp(this.configuration)
			.addPackToGenerate(packGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} packGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PackEmbeddingApi
	 */
	public findFamily(packGuid: string, options?: RawAxiosRequestConfig) {
		return PackEmbeddingApiFp(this.configuration)
			.findFamily(packGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} packGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PackEmbeddingApi
	 */
	public findSimilarPacks(packGuid: string, options?: RawAxiosRequestConfig) {
		return PackEmbeddingApiFp(this.configuration)
			.findSimilarPacks(packGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} packGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PackEmbeddingApi
	 */
	public getPackEmbedding(packGuid: string, options?: RawAxiosRequestConfig) {
		return PackEmbeddingApiFp(this.configuration)
			.getPackEmbedding(packGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} searchKey
	 * @param {number} [page]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PackEmbeddingApi
	 */
	public search(
		searchKey: string,
		page?: number,
		options?: RawAxiosRequestConfig
	) {
		return PackEmbeddingApiFp(this.configuration)
			.search(searchKey, page, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} packGuid
	 * @param {string} text
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PackEmbeddingApi
	 */
	public testPackVectorize(
		packGuid: string,
		text: string,
		options?: RawAxiosRequestConfig
	) {
		return PackEmbeddingApiFp(this.configuration)
			.testPackVectorize(packGuid, text, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} text1
	 * @param {string} text2
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PackEmbeddingApi
	 */
	public testVectorize(
		text1: string,
		text2: string,
		options?: RawAxiosRequestConfig
	) {
		return PackEmbeddingApiFp(this.configuration)
			.testVectorize(text1, text2, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * ParserApi - axios parameter creator
 * @export
 */
export const ParserApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getJobResult: async (
			id: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('getJobResult', 'id', id)
			const localVarPath = `/parser/get-job-result`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (id !== undefined) {
				localVarQueryParameter['id'] = id
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getJobStatus: async (
			id: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'id' is not null or undefined
			assertParamExists('getJobStatus', 'id', id)
			const localVarPath = `/parser/get-job-status`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (id !== undefined) {
				localVarQueryParameter['id'] = id
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		isAvailable: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/parser/is-available`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		parse: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/parser/parse-file`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ParserApi - functional programming interface
 * @export
 */
export const ParserApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = ParserApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getJobResult(
			id: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ParserSongDataResult>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getJobResult(
				id,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ParserApi.getJobResult']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getJobStatus(
			id: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getJobStatus(
				id,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ParserApi.getJobStatus']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async isAvailable(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.isAvailable(
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ParserApi.isAvailable']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async parse(
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<AddFileToParseQueueOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.parse(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ParserApi.parse']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * ParserApi - factory interface
 * @export
 */
export const ParserApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = ParserApiFp(configuration)
	return {
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getJobResult(
			id: string,
			options?: any
		): AxiosPromise<ParserSongDataResult> {
			return localVarFp
				.getJobResult(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} id
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getJobStatus(id: string, options?: any): AxiosPromise<void> {
			return localVarFp
				.getJobStatus(id, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		isAvailable(options?: any): AxiosPromise<boolean> {
			return localVarFp
				.isAvailable(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		parse(options?: any): AxiosPromise<AddFileToParseQueueOutDto> {
			return localVarFp
				.parse(options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * ParserApi - object-oriented interface
 * @export
 * @class ParserApi
 * @extends {BaseAPI}
 */
export class ParserApi extends BaseAPI {
	/**
	 *
	 * @param {string} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ParserApi
	 */
	public getJobResult(id: string, options?: RawAxiosRequestConfig) {
		return ParserApiFp(this.configuration)
			.getJobResult(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} id
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ParserApi
	 */
	public getJobStatus(id: string, options?: RawAxiosRequestConfig) {
		return ParserApiFp(this.configuration)
			.getJobStatus(id, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ParserApi
	 */
	public isAvailable(options?: RawAxiosRequestConfig) {
		return ParserApiFp(this.configuration)
			.isAvailable(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ParserApi
	 */
	public parse(options?: RawAxiosRequestConfig) {
		return ParserApiFp(this.configuration)
			.parse(options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * PermissionsApi - axios parameter creator
 * @export
 */
export const PermissionsApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addPermissionToGroup: async (
			addPermissionToGroupInDto: AddPermissionToGroupInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'addPermissionToGroupInDto' is not null or undefined
			assertParamExists(
				'addPermissionToGroup',
				'addPermissionToGroupInDto',
				addPermissionToGroupInDto
			)
			const localVarPath = `/permissions/group/add`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				addPermissionToGroupInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {AddPermissionToUserInDto} addPermissionToUserInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addPermissionToUser: async (
			addPermissionToUserInDto: AddPermissionToUserInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'addPermissionToUserInDto' is not null or undefined
			assertParamExists(
				'addPermissionToUser',
				'addPermissionToUserInDto',
				addPermissionToUserInDto
			)
			const localVarPath = `/permissions/user/add`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				addPermissionToUserInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} type
		 * @param {string} [payload]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getAllUsersWithPermission: async (
			type: string,
			payload?: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'type' is not null or undefined
			assertParamExists('getAllUsersWithPermission', 'type', type)
			const localVarPath = `/permissions/users`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (type !== undefined) {
				localVarQueryParameter['type'] = type
			}

			if (payload !== undefined) {
				localVarQueryParameter['payload'] = payload
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOrAddPermission: async (
			getOrCreatePermissionInDto: GetOrCreatePermissionInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'getOrCreatePermissionInDto' is not null or undefined
			assertParamExists(
				'getOrAddPermission',
				'getOrCreatePermissionInDto',
				getOrCreatePermissionInDto
			)
			const localVarPath = `/permissions/get`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				getOrCreatePermissionInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} [userGuid]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUserPermissions: async (
			userGuid?: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/permissions/user`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (userGuid !== undefined) {
				localVarQueryParameter['userGuid'] = userGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removePermissionFromGroup: async (
			addPermissionToGroupInDto: AddPermissionToGroupInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'addPermissionToGroupInDto' is not null or undefined
			assertParamExists(
				'removePermissionFromGroup',
				'addPermissionToGroupInDto',
				addPermissionToGroupInDto
			)
			const localVarPath = `/permissions/group/remove`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				addPermissionToGroupInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {AddPermissionToUserInDto} addPermissionToUserInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removePermissionFromUser: async (
			addPermissionToUserInDto: AddPermissionToUserInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'addPermissionToUserInDto' is not null or undefined
			assertParamExists(
				'removePermissionFromUser',
				'addPermissionToUserInDto',
				addPermissionToUserInDto
			)
			const localVarPath = `/permissions/user/remove`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				addPermissionToUserInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * PermissionsApi - functional programming interface
 * @export
 */
export const PermissionsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		PermissionsApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addPermissionToGroup(
			addPermissionToGroupInDto: AddPermissionToGroupInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<PermissionUserGroup>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addPermissionToGroup(
					addPermissionToGroupInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PermissionsApi.addPermissionToGroup']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {AddPermissionToUserInDto} addPermissionToUserInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addPermissionToUser(
			addPermissionToUserInDto: AddPermissionToUserInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addPermissionToUser(
					addPermissionToUserInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PermissionsApi.addPermissionToUser']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} type
		 * @param {string} [payload]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getAllUsersWithPermission(
			type: string,
			payload?: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<PermissionUserBaseOutDto>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getAllUsersWithPermission(
					type,
					payload,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PermissionsApi.getAllUsersWithPermission']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getOrAddPermission(
			getOrCreatePermissionInDto: GetOrCreatePermissionInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getOrAddPermission(
					getOrCreatePermissionInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PermissionsApi.getOrAddPermission']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} [userGuid]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getUserPermissions(
			userGuid?: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<GetUserPermissionOutDto>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getUserPermissions(userGuid, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PermissionsApi.getUserPermissions']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async removePermissionFromGroup(
			addPermissionToGroupInDto: AddPermissionToGroupInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<PermissionUserGroup>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.removePermissionFromGroup(
					addPermissionToGroupInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PermissionsApi.removePermissionFromGroup']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {AddPermissionToUserInDto} addPermissionToUserInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async removePermissionFromUser(
			addPermissionToUserInDto: AddPermissionToUserInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permission>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.removePermissionFromUser(
					addPermissionToUserInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PermissionsApi.removePermissionFromUser']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * PermissionsApi - factory interface
 * @export
 */
export const PermissionsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = PermissionsApiFp(configuration)
	return {
		/**
		 *
		 * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addPermissionToGroup(
			addPermissionToGroupInDto: AddPermissionToGroupInDto,
			options?: any
		): AxiosPromise<PermissionUserGroup> {
			return localVarFp
				.addPermissionToGroup(addPermissionToGroupInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {AddPermissionToUserInDto} addPermissionToUserInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addPermissionToUser(
			addPermissionToUserInDto: AddPermissionToUserInDto,
			options?: any
		): AxiosPromise<Permission> {
			return localVarFp
				.addPermissionToUser(addPermissionToUserInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} type
		 * @param {string} [payload]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getAllUsersWithPermission(
			type: string,
			payload?: string,
			options?: any
		): AxiosPromise<Array<PermissionUserBaseOutDto>> {
			return localVarFp
				.getAllUsersWithPermission(type, payload, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getOrAddPermission(
			getOrCreatePermissionInDto: GetOrCreatePermissionInDto,
			options?: any
		): AxiosPromise<Permission> {
			return localVarFp
				.getOrAddPermission(getOrCreatePermissionInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} [userGuid]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUserPermissions(
			userGuid?: string,
			options?: any
		): AxiosPromise<Array<GetUserPermissionOutDto>> {
			return localVarFp
				.getUserPermissions(userGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removePermissionFromGroup(
			addPermissionToGroupInDto: AddPermissionToGroupInDto,
			options?: any
		): AxiosPromise<PermissionUserGroup> {
			return localVarFp
				.removePermissionFromGroup(addPermissionToGroupInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {AddPermissionToUserInDto} addPermissionToUserInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removePermissionFromUser(
			addPermissionToUserInDto: AddPermissionToUserInDto,
			options?: any
		): AxiosPromise<Permission> {
			return localVarFp
				.removePermissionFromUser(addPermissionToUserInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * PermissionsApi - object-oriented interface
 * @export
 * @class PermissionsApi
 * @extends {BaseAPI}
 */
export class PermissionsApi extends BaseAPI {
	/**
	 *
	 * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PermissionsApi
	 */
	public addPermissionToGroup(
		addPermissionToGroupInDto: AddPermissionToGroupInDto,
		options?: RawAxiosRequestConfig
	) {
		return PermissionsApiFp(this.configuration)
			.addPermissionToGroup(addPermissionToGroupInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {AddPermissionToUserInDto} addPermissionToUserInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PermissionsApi
	 */
	public addPermissionToUser(
		addPermissionToUserInDto: AddPermissionToUserInDto,
		options?: RawAxiosRequestConfig
	) {
		return PermissionsApiFp(this.configuration)
			.addPermissionToUser(addPermissionToUserInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} type
	 * @param {string} [payload]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PermissionsApi
	 */
	public getAllUsersWithPermission(
		type: string,
		payload?: string,
		options?: RawAxiosRequestConfig
	) {
		return PermissionsApiFp(this.configuration)
			.getAllUsersWithPermission(type, payload, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {GetOrCreatePermissionInDto} getOrCreatePermissionInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PermissionsApi
	 */
	public getOrAddPermission(
		getOrCreatePermissionInDto: GetOrCreatePermissionInDto,
		options?: RawAxiosRequestConfig
	) {
		return PermissionsApiFp(this.configuration)
			.getOrAddPermission(getOrCreatePermissionInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} [userGuid]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PermissionsApi
	 */
	public getUserPermissions(
		userGuid?: string,
		options?: RawAxiosRequestConfig
	) {
		return PermissionsApiFp(this.configuration)
			.getUserPermissions(userGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {AddPermissionToGroupInDto} addPermissionToGroupInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PermissionsApi
	 */
	public removePermissionFromGroup(
		addPermissionToGroupInDto: AddPermissionToGroupInDto,
		options?: RawAxiosRequestConfig
	) {
		return PermissionsApiFp(this.configuration)
			.removePermissionFromGroup(addPermissionToGroupInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {AddPermissionToUserInDto} addPermissionToUserInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PermissionsApi
	 */
	public removePermissionFromUser(
		addPermissionToUserInDto: AddPermissionToUserInDto,
		options?: RawAxiosRequestConfig
	) {
		return PermissionsApiFp(this.configuration)
			.removePermissionFromUser(addPermissionToUserInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * PlaylistEditingApi - axios parameter creator
 * @export
 */
export const PlaylistEditingApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addVariantToPlaylist: async (
			addVariantToPlaylistInDto: AddVariantToPlaylistInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'addVariantToPlaylistInDto' is not null or undefined
			assertParamExists(
				'addVariantToPlaylist',
				'addVariantToPlaylistInDto',
				addVariantToPlaylistInDto
			)
			const localVarPath = `/playlist/add`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				addVariantToPlaylistInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {PlaylistComplexEditInDto} playlistComplexEditInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		complexPlaylistEdit: async (
			playlistComplexEditInDto: PlaylistComplexEditInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'playlistComplexEditInDto' is not null or undefined
			assertParamExists(
				'complexPlaylistEdit',
				'playlistComplexEditInDto',
				playlistComplexEditInDto
			)
			const localVarPath = `/playlist/complex`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				playlistComplexEditInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createPlaylist: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/playlist`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} guid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deletePlaylist: async (
			guid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'guid' is not null or undefined
			assertParamExists('deletePlaylist', 'guid', guid)
			const localVarPath = `/playlist`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (guid !== undefined) {
				localVarQueryParameter['guid'] = guid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {EditItemInDto} editItemInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		editItem: async (
			editItemInDto: EditItemInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'editItemInDto' is not null or undefined
			assertParamExists('editItem', 'editItemInDto', editItemInDto)
			const localVarPath = `/playlist/edititem`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				editItemInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} itemGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		isItemEditable: async (
			itemGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'itemGuid' is not null or undefined
			assertParamExists('isItemEditable', 'itemGuid', itemGuid)
			const localVarPath = `/playlist/isitemeditable`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (itemGuid !== undefined) {
				localVarQueryParameter['itemGuid'] = itemGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {string} playlist
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removeVariantFromPlaylistDelete: async (
			packGuid: string,
			playlist: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('removeVariantFromPlaylistDelete', 'packGuid', packGuid)
			// verify required parameter 'playlist' is not null or undefined
			assertParamExists('removeVariantFromPlaylistDelete', 'playlist', playlist)
			const localVarPath = `/playlist/remove`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (packGuid !== undefined) {
				localVarQueryParameter['packGuid'] = packGuid
			}

			if (playlist !== undefined) {
				localVarQueryParameter['playlist'] = playlist
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {RenamePlaylistInDto} renamePlaylistInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		renamePlaylist: async (
			renamePlaylistInDto: RenamePlaylistInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'renamePlaylistInDto' is not null or undefined
			assertParamExists(
				'renamePlaylist',
				'renamePlaylistInDto',
				renamePlaylistInDto
			)
			const localVarPath = `/playlist/rename`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'PUT',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				renamePlaylistInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {ReorderPlaylistInDto} reorderPlaylistInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		reorderPlaylist: async (
			reorderPlaylistInDto: ReorderPlaylistInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'reorderPlaylistInDto' is not null or undefined
			assertParamExists(
				'reorderPlaylist',
				'reorderPlaylistInDto',
				reorderPlaylistInDto
			)
			const localVarPath = `/playlist/reorder`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				reorderPlaylistInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {RequireItemEditInDto} requireItemEditInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		requireItemEdit: async (
			requireItemEditInDto: RequireItemEditInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'requireItemEditInDto' is not null or undefined
			assertParamExists(
				'requireItemEdit',
				'requireItemEditInDto',
				requireItemEditInDto
			)
			const localVarPath = `/playlist/requireItemEdit`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				requireItemEditInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		transposePlaylistItem: async (
			transposePlaylistItemInDto: TransposePlaylistItemInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'transposePlaylistItemInDto' is not null or undefined
			assertParamExists(
				'transposePlaylistItem',
				'transposePlaylistItemInDto',
				transposePlaylistItemInDto
			)
			const localVarPath = `/playlist/transpose`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				transposePlaylistItemInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * PlaylistEditingApi - functional programming interface
 * @export
 */
export const PlaylistEditingApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		PlaylistEditingApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addVariantToPlaylist(
			addVariantToPlaylistInDto: AddVariantToPlaylistInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<PlaylistItemOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addVariantToPlaylist(
					addVariantToPlaylistInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PlaylistEditingApi.addVariantToPlaylist']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {PlaylistComplexEditInDto} playlistComplexEditInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async complexPlaylistEdit(
			playlistComplexEditInDto: PlaylistComplexEditInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.complexPlaylistEdit(
					playlistComplexEditInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PlaylistEditingApi.complexPlaylistEdit']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createPlaylist(
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<PostCreatePlaylistResult>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createPlaylist(
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PlaylistEditingApi.createPlaylist']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} guid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deletePlaylist(
			guid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlaylist(
				guid,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PlaylistEditingApi.deletePlaylist']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {EditItemInDto} editItemInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async editItem(
			editItemInDto: EditItemInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.editItem(
				editItemInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PlaylistEditingApi.editItem']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} itemGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async isItemEditable(
			itemGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.isItemEditable(
				itemGuid,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PlaylistEditingApi.isItemEditable']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {string} playlist
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async removeVariantFromPlaylistDelete(
			packGuid: string,
			playlist: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.removeVariantFromPlaylistDelete(
					packGuid,
					playlist,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap[
					'PlaylistEditingApi.removeVariantFromPlaylistDelete'
				]?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {RenamePlaylistInDto} renamePlaylistInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async renamePlaylist(
			renamePlaylistInDto: RenamePlaylistInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.renamePlaylist(
				renamePlaylistInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PlaylistEditingApi.renamePlaylist']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {ReorderPlaylistInDto} reorderPlaylistInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async reorderPlaylist(
			reorderPlaylistInDto: ReorderPlaylistInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.reorderPlaylist(
				reorderPlaylistInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PlaylistEditingApi.reorderPlaylist']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {RequireItemEditInDto} requireItemEditInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async requireItemEdit(
			requireItemEditInDto: RequireItemEditInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<RequireItemEditOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.requireItemEdit(
				requireItemEditInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PlaylistEditingApi.requireItemEdit']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async transposePlaylistItem(
			transposePlaylistItemInDto: TransposePlaylistItemInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.transposePlaylistItem(
					transposePlaylistItemInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PlaylistEditingApi.transposePlaylistItem']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * PlaylistEditingApi - factory interface
 * @export
 */
export const PlaylistEditingApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = PlaylistEditingApiFp(configuration)
	return {
		/**
		 *
		 * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addVariantToPlaylist(
			addVariantToPlaylistInDto: AddVariantToPlaylistInDto,
			options?: any
		): AxiosPromise<PlaylistItemOutDto> {
			return localVarFp
				.addVariantToPlaylist(addVariantToPlaylistInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {PlaylistComplexEditInDto} playlistComplexEditInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		complexPlaylistEdit(
			playlistComplexEditInDto: PlaylistComplexEditInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.complexPlaylistEdit(playlistComplexEditInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createPlaylist(options?: any): AxiosPromise<PostCreatePlaylistResult> {
			return localVarFp
				.createPlaylist(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} guid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deletePlaylist(guid: string, options?: any): AxiosPromise<boolean> {
			return localVarFp
				.deletePlaylist(guid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {EditItemInDto} editItemInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		editItem(editItemInDto: EditItemInDto, options?: any): AxiosPromise<void> {
			return localVarFp
				.editItem(editItemInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} itemGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		isItemEditable(itemGuid: string, options?: any): AxiosPromise<boolean> {
			return localVarFp
				.isItemEditable(itemGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {string} playlist
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removeVariantFromPlaylistDelete(
			packGuid: string,
			playlist: string,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.removeVariantFromPlaylistDelete(packGuid, playlist, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {RenamePlaylistInDto} renamePlaylistInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		renamePlaylist(
			renamePlaylistInDto: RenamePlaylistInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.renamePlaylist(renamePlaylistInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {ReorderPlaylistInDto} reorderPlaylistInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		reorderPlaylist(
			reorderPlaylistInDto: ReorderPlaylistInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.reorderPlaylist(reorderPlaylistInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {RequireItemEditInDto} requireItemEditInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		requireItemEdit(
			requireItemEditInDto: RequireItemEditInDto,
			options?: any
		): AxiosPromise<RequireItemEditOutDto> {
			return localVarFp
				.requireItemEdit(requireItemEditInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		transposePlaylistItem(
			transposePlaylistItemInDto: TransposePlaylistItemInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.transposePlaylistItem(transposePlaylistItemInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * PlaylistEditingApi - object-oriented interface
 * @export
 * @class PlaylistEditingApi
 * @extends {BaseAPI}
 */
export class PlaylistEditingApi extends BaseAPI {
	/**
	 *
	 * @param {AddVariantToPlaylistInDto} addVariantToPlaylistInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistEditingApi
	 */
	public addVariantToPlaylist(
		addVariantToPlaylistInDto: AddVariantToPlaylistInDto,
		options?: RawAxiosRequestConfig
	) {
		return PlaylistEditingApiFp(this.configuration)
			.addVariantToPlaylist(addVariantToPlaylistInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {PlaylistComplexEditInDto} playlistComplexEditInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistEditingApi
	 */
	public complexPlaylistEdit(
		playlistComplexEditInDto: PlaylistComplexEditInDto,
		options?: RawAxiosRequestConfig
	) {
		return PlaylistEditingApiFp(this.configuration)
			.complexPlaylistEdit(playlistComplexEditInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistEditingApi
	 */
	public createPlaylist(options?: RawAxiosRequestConfig) {
		return PlaylistEditingApiFp(this.configuration)
			.createPlaylist(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} guid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistEditingApi
	 */
	public deletePlaylist(guid: string, options?: RawAxiosRequestConfig) {
		return PlaylistEditingApiFp(this.configuration)
			.deletePlaylist(guid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {EditItemInDto} editItemInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistEditingApi
	 */
	public editItem(
		editItemInDto: EditItemInDto,
		options?: RawAxiosRequestConfig
	) {
		return PlaylistEditingApiFp(this.configuration)
			.editItem(editItemInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} itemGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistEditingApi
	 */
	public isItemEditable(itemGuid: string, options?: RawAxiosRequestConfig) {
		return PlaylistEditingApiFp(this.configuration)
			.isItemEditable(itemGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} packGuid
	 * @param {string} playlist
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistEditingApi
	 */
	public removeVariantFromPlaylistDelete(
		packGuid: string,
		playlist: string,
		options?: RawAxiosRequestConfig
	) {
		return PlaylistEditingApiFp(this.configuration)
			.removeVariantFromPlaylistDelete(packGuid, playlist, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {RenamePlaylistInDto} renamePlaylistInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistEditingApi
	 */
	public renamePlaylist(
		renamePlaylistInDto: RenamePlaylistInDto,
		options?: RawAxiosRequestConfig
	) {
		return PlaylistEditingApiFp(this.configuration)
			.renamePlaylist(renamePlaylistInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {ReorderPlaylistInDto} reorderPlaylistInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistEditingApi
	 */
	public reorderPlaylist(
		reorderPlaylistInDto: ReorderPlaylistInDto,
		options?: RawAxiosRequestConfig
	) {
		return PlaylistEditingApiFp(this.configuration)
			.reorderPlaylist(reorderPlaylistInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {RequireItemEditInDto} requireItemEditInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistEditingApi
	 */
	public requireItemEdit(
		requireItemEditInDto: RequireItemEditInDto,
		options?: RawAxiosRequestConfig
	) {
		return PlaylistEditingApiFp(this.configuration)
			.requireItemEdit(requireItemEditInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {TransposePlaylistItemInDto} transposePlaylistItemInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistEditingApi
	 */
	public transposePlaylistItem(
		transposePlaylistItemInDto: TransposePlaylistItemInDto,
		options?: RawAxiosRequestConfig
	) {
		return PlaylistEditingApiFp(this.configuration)
			.transposePlaylistItem(transposePlaylistItemInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * PlaylistGettingApi - axios parameter creator
 * @export
 */
export const PlaylistGettingApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} guid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPlaylistDataByGuid: async (
			guid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'guid' is not null or undefined
			assertParamExists('getPlaylistDataByGuid', 'guid', guid)
			const localVarPath = `/playlist/data`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (guid !== undefined) {
				localVarQueryParameter['guid'] = guid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPlaylistsOfUser: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/playlist/ofuser`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {string} playlist
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		isVariantInPlaylist: async (
			packGuid: string,
			playlist: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('isVariantInPlaylist', 'packGuid', packGuid)
			// verify required parameter 'playlist' is not null or undefined
			assertParamExists('isVariantInPlaylist', 'playlist', playlist)
			const localVarPath = `/playlist/contains`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (packGuid !== undefined) {
				localVarQueryParameter['packGuid'] = packGuid
			}

			if (playlist !== undefined) {
				localVarQueryParameter['playlist'] = playlist
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} searchKey
		 * @param {string} playlist
		 * @param {number} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		searchInPlaylist: async (
			searchKey: string,
			playlist: string,
			page?: number,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'searchKey' is not null or undefined
			assertParamExists('searchInPlaylist', 'searchKey', searchKey)
			// verify required parameter 'playlist' is not null or undefined
			assertParamExists('searchInPlaylist', 'playlist', playlist)
			const localVarPath = `/playlist/search`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (searchKey !== undefined) {
				localVarQueryParameter['searchKey'] = searchKey
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page
			}

			if (playlist !== undefined) {
				localVarQueryParameter['playlist'] = playlist
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} playlistGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updatePlaylistOpenDate: async (
			playlistGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'playlistGuid' is not null or undefined
			assertParamExists('updatePlaylistOpenDate', 'playlistGuid', playlistGuid)
			const localVarPath = `/playlist/updateopendate`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (playlistGuid !== undefined) {
				localVarQueryParameter['playlistGuid'] = playlistGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * PlaylistGettingApi - functional programming interface
 * @export
 */
export const PlaylistGettingApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		PlaylistGettingApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {string} guid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getPlaylistDataByGuid(
			guid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<PlaylistDataOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getPlaylistDataByGuid(guid, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PlaylistGettingApi.getPlaylistDataByGuid']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getPlaylistsOfUser(
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetPlaylistsResult>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getPlaylistsOfUser(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PlaylistGettingApi.getPlaylistsOfUser']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {string} playlist
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async isVariantInPlaylist(
			packGuid: string,
			playlist: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.isVariantInPlaylist(
					packGuid,
					playlist,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PlaylistGettingApi.isVariantInPlaylist']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} searchKey
		 * @param {string} playlist
		 * @param {number} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async searchInPlaylist(
			searchKey: string,
			playlist: string,
			page?: number,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetSearchInPlaylistResult>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.searchInPlaylist(
					searchKey,
					playlist,
					page,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PlaylistGettingApi.searchInPlaylist']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} playlistGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updatePlaylistOpenDate(
			playlistGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.updatePlaylistOpenDate(
					playlistGuid,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['PlaylistGettingApi.updatePlaylistOpenDate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * PlaylistGettingApi - factory interface
 * @export
 */
export const PlaylistGettingApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = PlaylistGettingApiFp(configuration)
	return {
		/**
		 *
		 * @param {string} guid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPlaylistDataByGuid(
			guid: string,
			options?: any
		): AxiosPromise<PlaylistDataOutDto> {
			return localVarFp
				.getPlaylistDataByGuid(guid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPlaylistsOfUser(options?: any): AxiosPromise<GetPlaylistsResult> {
			return localVarFp
				.getPlaylistsOfUser(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {string} playlist
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		isVariantInPlaylist(
			packGuid: string,
			playlist: string,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.isVariantInPlaylist(packGuid, playlist, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} searchKey
		 * @param {string} playlist
		 * @param {number} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		searchInPlaylist(
			searchKey: string,
			playlist: string,
			page?: number,
			options?: any
		): AxiosPromise<GetSearchInPlaylistResult> {
			return localVarFp
				.searchInPlaylist(searchKey, playlist, page, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} playlistGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updatePlaylistOpenDate(
			playlistGuid: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.updatePlaylistOpenDate(playlistGuid, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * PlaylistGettingApi - object-oriented interface
 * @export
 * @class PlaylistGettingApi
 * @extends {BaseAPI}
 */
export class PlaylistGettingApi extends BaseAPI {
	/**
	 *
	 * @param {string} guid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistGettingApi
	 */
	public getPlaylistDataByGuid(guid: string, options?: RawAxiosRequestConfig) {
		return PlaylistGettingApiFp(this.configuration)
			.getPlaylistDataByGuid(guid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistGettingApi
	 */
	public getPlaylistsOfUser(options?: RawAxiosRequestConfig) {
		return PlaylistGettingApiFp(this.configuration)
			.getPlaylistsOfUser(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} packGuid
	 * @param {string} playlist
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistGettingApi
	 */
	public isVariantInPlaylist(
		packGuid: string,
		playlist: string,
		options?: RawAxiosRequestConfig
	) {
		return PlaylistGettingApiFp(this.configuration)
			.isVariantInPlaylist(packGuid, playlist, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} searchKey
	 * @param {string} playlist
	 * @param {number} [page]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistGettingApi
	 */
	public searchInPlaylist(
		searchKey: string,
		playlist: string,
		page?: number,
		options?: RawAxiosRequestConfig
	) {
		return PlaylistGettingApiFp(this.configuration)
			.searchInPlaylist(searchKey, playlist, page, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} playlistGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof PlaylistGettingApi
	 */
	public updatePlaylistOpenDate(
		playlistGuid: string,
		options?: RawAxiosRequestConfig
	) {
		return PlaylistGettingApiFp(this.configuration)
			.updatePlaylistOpenDate(playlistGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * ProgramSongAddingApi - axios parameter creator
 * @export
 */
export const ProgramSongAddingApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 * This function process data stream from loader\'s program. Getter and so on.
		 * @summary
		 * @param {ProgramSongData} programSongData
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		processDataStream: async (
			programSongData: ProgramSongData,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'programSongData' is not null or undefined
			assertParamExists('processDataStream', 'programSongData', programSongData)
			const localVarPath = `/song/processdatastream`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				programSongData,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		test: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/song/test`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * ProgramSongAddingApi - functional programming interface
 * @export
 */
export const ProgramSongAddingApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		ProgramSongAddingApiAxiosParamCreator(configuration)
	return {
		/**
		 * This function process data stream from loader\'s program. Getter and so on.
		 * @summary
		 * @param {ProgramSongData} programSongData
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async processDataStream(
			programSongData: ProgramSongData,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.processDataStream(
					programSongData,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ProgramSongAddingApi.processDataStream']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async test(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.test(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['ProgramSongAddingApi.test']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * ProgramSongAddingApi - factory interface
 * @export
 */
export const ProgramSongAddingApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = ProgramSongAddingApiFp(configuration)
	return {
		/**
		 * This function process data stream from loader\'s program. Getter and so on.
		 * @summary
		 * @param {ProgramSongData} programSongData
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		processDataStream(
			programSongData: ProgramSongData,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.processDataStream(programSongData, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		test(options?: any): AxiosPromise<string> {
			return localVarFp
				.test(options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * ProgramSongAddingApi - object-oriented interface
 * @export
 * @class ProgramSongAddingApi
 * @extends {BaseAPI}
 */
export class ProgramSongAddingApi extends BaseAPI {
	/**
	 * This function process data stream from loader\'s program. Getter and so on.
	 * @summary
	 * @param {ProgramSongData} programSongData
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProgramSongAddingApi
	 */
	public processDataStream(
		programSongData: ProgramSongData,
		options?: RawAxiosRequestConfig
	) {
		return ProgramSongAddingApiFp(this.configuration)
			.processDataStream(programSongData, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof ProgramSongAddingApi
	 */
	public test(options?: RawAxiosRequestConfig) {
		return ProgramSongAddingApiFp(this.configuration)
			.test(options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * SongAddingApi - axios parameter creator
 * @export
 */
export const SongAddingApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {PostCreateVariantInDto} postCreateVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		create: async (
			postCreateVariantInDto: PostCreateVariantInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postCreateVariantInDto' is not null or undefined
			assertParamExists(
				'create',
				'postCreateVariantInDto',
				postCreateVariantInDto
			)
			const localVarPath = `/song`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postCreateVariantInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {PostCreateCopyInDto} postCreateCopyInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createCopy: async (
			postCreateCopyInDto: PostCreateCopyInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postCreateCopyInDto' is not null or undefined
			assertParamExists(
				'createCopy',
				'postCreateCopyInDto',
				postCreateCopyInDto
			)
			const localVarPath = `/song/create/copy`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postCreateCopyInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * SongAddingApi - functional programming interface
 * @export
 */
export const SongAddingApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		SongAddingApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {PostCreateVariantInDto} postCreateVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async create(
			postCreateVariantInDto: PostCreateVariantInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<PostCreateVariantOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.create(
				postCreateVariantInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongAddingApi.create']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {PostCreateCopyInDto} postCreateCopyInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createCopy(
			postCreateCopyInDto: PostCreateCopyInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<PostCreateCopyOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createCopy(
				postCreateCopyInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongAddingApi.createCopy']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * SongAddingApi - factory interface
 * @export
 */
export const SongAddingApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SongAddingApiFp(configuration)
	return {
		/**
		 *
		 * @param {PostCreateVariantInDto} postCreateVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		create(
			postCreateVariantInDto: PostCreateVariantInDto,
			options?: any
		): AxiosPromise<PostCreateVariantOutDto> {
			return localVarFp
				.create(postCreateVariantInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {PostCreateCopyInDto} postCreateCopyInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createCopy(
			postCreateCopyInDto: PostCreateCopyInDto,
			options?: any
		): AxiosPromise<PostCreateCopyOutDto> {
			return localVarFp
				.createCopy(postCreateCopyInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * SongAddingApi - object-oriented interface
 * @export
 * @class SongAddingApi
 * @extends {BaseAPI}
 */
export class SongAddingApi extends BaseAPI {
	/**
	 *
	 * @param {PostCreateVariantInDto} postCreateVariantInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongAddingApi
	 */
	public create(
		postCreateVariantInDto: PostCreateVariantInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongAddingApiFp(this.configuration)
			.create(postCreateVariantInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {PostCreateCopyInDto} postCreateCopyInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongAddingApi
	 */
	public createCopy(
		postCreateCopyInDto: PostCreateCopyInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongAddingApiFp(this.configuration)
			.createCopy(postCreateCopyInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * SongCreatorsApi - axios parameter creator
 * @export
 */
export const SongCreatorsApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} input
		 * @param {number} [limit]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		autoComplete: async (
			input: string,
			limit?: number,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'input' is not null or undefined
			assertParamExists('autoComplete', 'input', input)
			const localVarPath = `/song/creators/autocomplete`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (input !== undefined) {
				localVarQueryParameter['input'] = input
			}

			if (limit !== undefined) {
				localVarQueryParameter['limit'] = limit
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {PostSetCreatorsToPackInDto} postSetCreatorsToPackInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		setToPack: async (
			postSetCreatorsToPackInDto: PostSetCreatorsToPackInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postSetCreatorsToPackInDto' is not null or undefined
			assertParamExists(
				'setToPack',
				'postSetCreatorsToPackInDto',
				postSetCreatorsToPackInDto
			)
			const localVarPath = `/song/creators/set-to-pack`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postSetCreatorsToPackInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * SongCreatorsApi - functional programming interface
 * @export
 */
export const SongCreatorsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		SongCreatorsApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {string} input
		 * @param {number} [limit]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async autoComplete(
			input: string,
			limit?: number,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<GetCreatorAutoCompleteItemDto>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.autoComplete(
				input,
				limit,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongCreatorsApi.autoComplete']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {PostSetCreatorsToPackInDto} postSetCreatorsToPackInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async setToPack(
			postSetCreatorsToPackInDto: PostSetCreatorsToPackInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.setToPack(
				postSetCreatorsToPackInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongCreatorsApi.setToPack']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * SongCreatorsApi - factory interface
 * @export
 */
export const SongCreatorsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SongCreatorsApiFp(configuration)
	return {
		/**
		 *
		 * @param {string} input
		 * @param {number} [limit]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		autoComplete(
			input: string,
			limit?: number,
			options?: any
		): AxiosPromise<Array<GetCreatorAutoCompleteItemDto>> {
			return localVarFp
				.autoComplete(input, limit, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {PostSetCreatorsToPackInDto} postSetCreatorsToPackInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		setToPack(
			postSetCreatorsToPackInDto: PostSetCreatorsToPackInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.setToPack(postSetCreatorsToPackInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * SongCreatorsApi - object-oriented interface
 * @export
 * @class SongCreatorsApi
 * @extends {BaseAPI}
 */
export class SongCreatorsApi extends BaseAPI {
	/**
	 *
	 * @param {string} input
	 * @param {number} [limit]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongCreatorsApi
	 */
	public autoComplete(
		input: string,
		limit?: number,
		options?: RawAxiosRequestConfig
	) {
		return SongCreatorsApiFp(this.configuration)
			.autoComplete(input, limit, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {PostSetCreatorsToPackInDto} postSetCreatorsToPackInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongCreatorsApi
	 */
	public setToPack(
		postSetCreatorsToPackInDto: PostSetCreatorsToPackInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongCreatorsApiFp(this.configuration)
			.setToPack(postSetCreatorsToPackInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * SongDeletingApi - axios parameter creator
 * @export
 */
export const SongDeletingApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		_delete: async (
			packGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('_delete', 'packGuid', packGuid)
			const localVarPath = `/song/variant/delete/{packGuid}`.replace(
				`{${'packGuid'}}`,
				encodeURIComponent(String(packGuid))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		restore: async (
			packGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('restore', 'packGuid', packGuid)
			const localVarPath = `/song/variant/restore/{packGuid}`.replace(
				`{${'packGuid'}}`,
				encodeURIComponent(String(packGuid))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * SongDeletingApi - functional programming interface
 * @export
 */
export const SongDeletingApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		SongDeletingApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async _delete(
			packGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator._delete(
				packGuid,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongDeletingApi._delete']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async restore(
			packGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.restore(
				packGuid,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongDeletingApi.restore']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * SongDeletingApi - factory interface
 * @export
 */
export const SongDeletingApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SongDeletingApiFp(configuration)
	return {
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		_delete(packGuid: string, options?: any): AxiosPromise<boolean> {
			return localVarFp
				._delete(packGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		restore(packGuid: string, options?: any): AxiosPromise<boolean> {
			return localVarFp
				.restore(packGuid, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * SongDeletingApi - object-oriented interface
 * @export
 * @class SongDeletingApi
 * @extends {BaseAPI}
 */
export class SongDeletingApi extends BaseAPI {
	/**
	 *
	 * @param {string} packGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongDeletingApi
	 */
	public _delete(packGuid: string, options?: RawAxiosRequestConfig) {
		return SongDeletingApiFp(this.configuration)
			._delete(packGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} packGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongDeletingApi
	 */
	public restore(packGuid: string, options?: RawAxiosRequestConfig) {
		return SongDeletingApiFp(this.configuration)
			.restore(packGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * SongEditingApi - axios parameter creator
 * @export
 */
export const SongEditingApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {PostChangeLanguageInDto} postChangeLanguageInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		changeLanguage: async (
			postChangeLanguageInDto: PostChangeLanguageInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postChangeLanguageInDto' is not null or undefined
			assertParamExists(
				'changeLanguage',
				'postChangeLanguageInDto',
				postChangeLanguageInDto
			)
			const localVarPath = `/song/variant/language`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postChangeLanguageInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {PostEditVariantInDto} postEditVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		editVariant: async (
			postEditVariantInDto: PostEditVariantInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postEditVariantInDto' is not null or undefined
			assertParamExists(
				'editVariant',
				'postEditVariantInDto',
				postEditVariantInDto
			)
			const localVarPath = `/song/variant/edit`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postEditVariantInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * SongEditingApi - functional programming interface
 * @export
 */
export const SongEditingApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		SongEditingApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {PostChangeLanguageInDto} postChangeLanguageInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async changeLanguage(
			postChangeLanguageInDto: PostChangeLanguageInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SongVariant>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.changeLanguage(
				postChangeLanguageInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongEditingApi.changeLanguage']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {PostEditVariantInDto} postEditVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async editVariant(
			postEditVariantInDto: PostEditVariantInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<EditVariantOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.editVariant(
				postEditVariantInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongEditingApi.editVariant']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * SongEditingApi - factory interface
 * @export
 */
export const SongEditingApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SongEditingApiFp(configuration)
	return {
		/**
		 *
		 * @param {PostChangeLanguageInDto} postChangeLanguageInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		changeLanguage(
			postChangeLanguageInDto: PostChangeLanguageInDto,
			options?: any
		): AxiosPromise<SongVariant> {
			return localVarFp
				.changeLanguage(postChangeLanguageInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {PostEditVariantInDto} postEditVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		editVariant(
			postEditVariantInDto: PostEditVariantInDto,
			options?: any
		): AxiosPromise<EditVariantOutDto> {
			return localVarFp
				.editVariant(postEditVariantInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * SongEditingApi - object-oriented interface
 * @export
 * @class SongEditingApi
 * @extends {BaseAPI}
 */
export class SongEditingApi extends BaseAPI {
	/**
	 *
	 * @param {PostChangeLanguageInDto} postChangeLanguageInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongEditingApi
	 */
	public changeLanguage(
		postChangeLanguageInDto: PostChangeLanguageInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongEditingApiFp(this.configuration)
			.changeLanguage(postChangeLanguageInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {PostEditVariantInDto} postEditVariantInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongEditingApi
	 */
	public editVariant(
		postEditVariantInDto: PostEditVariantInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongEditingApiFp(this.configuration)
			.editVariant(postEditVariantInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * SongFavouritesApi - axios parameter creator
 * @export
 */
export const SongFavouritesApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {AddFavouriteInDto} addFavouriteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addFavourite: async (
			addFavouriteInDto: AddFavouriteInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'addFavouriteInDto' is not null or undefined
			assertParamExists('addFavourite', 'addFavouriteInDto', addFavouriteInDto)
			const localVarPath = `/song/favourites/add`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				addFavouriteInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getFavourites: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/song/favourites`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {RemoveFavouriteInDto} removeFavouriteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removeFavourite: async (
			removeFavouriteInDto: RemoveFavouriteInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'removeFavouriteInDto' is not null or undefined
			assertParamExists(
				'removeFavourite',
				'removeFavouriteInDto',
				removeFavouriteInDto
			)
			const localVarPath = `/song/favourites/remove`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				removeFavouriteInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * SongFavouritesApi - functional programming interface
 * @export
 */
export const SongFavouritesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		SongFavouritesApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {AddFavouriteInDto} addFavouriteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addFavourite(
			addFavouriteInDto: AddFavouriteInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaylistItem>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.addFavourite(
				addFavouriteInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongFavouritesApi.addFavourite']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getFavourites(
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetFavouritesOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getFavourites(
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongFavouritesApi.getFavourites']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {RemoveFavouriteInDto} removeFavouriteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async removeFavourite(
			removeFavouriteInDto: RemoveFavouriteInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.removeFavourite(
				removeFavouriteInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongFavouritesApi.removeFavourite']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * SongFavouritesApi - factory interface
 * @export
 */
export const SongFavouritesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SongFavouritesApiFp(configuration)
	return {
		/**
		 *
		 * @param {AddFavouriteInDto} addFavouriteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addFavourite(
			addFavouriteInDto: AddFavouriteInDto,
			options?: any
		): AxiosPromise<PlaylistItem> {
			return localVarFp
				.addFavourite(addFavouriteInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getFavourites(options?: any): AxiosPromise<GetFavouritesOutDto> {
			return localVarFp
				.getFavourites(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {RemoveFavouriteInDto} removeFavouriteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removeFavourite(
			removeFavouriteInDto: RemoveFavouriteInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.removeFavourite(removeFavouriteInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * SongFavouritesApi - object-oriented interface
 * @export
 * @class SongFavouritesApi
 * @extends {BaseAPI}
 */
export class SongFavouritesApi extends BaseAPI {
	/**
	 *
	 * @param {AddFavouriteInDto} addFavouriteInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongFavouritesApi
	 */
	public addFavourite(
		addFavouriteInDto: AddFavouriteInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongFavouritesApiFp(this.configuration)
			.addFavourite(addFavouriteInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongFavouritesApi
	 */
	public getFavourites(options?: RawAxiosRequestConfig) {
		return SongFavouritesApiFp(this.configuration)
			.getFavourites(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {RemoveFavouriteInDto} removeFavouriteInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongFavouritesApi
	 */
	public removeFavourite(
		removeFavouriteInDto: RemoveFavouriteInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongFavouritesApiFp(this.configuration)
			.removeFavourite(removeFavouriteInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * SongGettingApi - axios parameter creator
 * @export
 */
export const SongGettingApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBasicPackDataByPackGuid: async (
			packGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('getBasicPackDataByPackGuid', 'packGuid', packGuid)
			const localVarPath = `/one/basic-by-pack-guid/{packGuid}`.replace(
				`{${'packGuid'}}`,
				encodeURIComponent(String(packGuid))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} searchKey
		 * @param {number} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBySearch: async (
			searchKey: string,
			page?: number,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'searchKey' is not null or undefined
			assertParamExists('getBySearch', 'searchKey', searchKey)
			const localVarPath = `/song/search`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (searchKey !== undefined) {
				localVarQueryParameter['searchKey'] = searchKey
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLastAdded: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/song/getlastadded`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {number} [page]
		 * @param {number} [perPage]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getList: async (
			page?: number,
			perPage?: number,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/song/list`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (page !== undefined) {
				localVarQueryParameter['page'] = page
			}

			if (perPage !== undefined) {
				localVarQueryParameter['perPage'] = perPage
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getListSongCount: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/song/listsongcount`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} url
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPublicSongBySource: async (
			url: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'url' is not null or undefined
			assertParamExists('getPublicSongBySource', 'url', url)
			const localVarPath = `/song/publicsongbysource/{url}`.replace(
				`{${'url'}}`,
				encodeURIComponent(String(url))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRandom: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/song/random`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRecommendedSongs: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/song/recommended`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSitemapList: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/song/sitemapList`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} guid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSongDataByGuid: async (
			guid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'guid' is not null or undefined
			assertParamExists('getSongDataByGuid', 'guid', guid)
			const localVarPath = `/one/songDataByGuid`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (guid !== undefined) {
				localVarQueryParameter['guid'] = guid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} guid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSongDataByVariantGuid: async (
			guid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'guid' is not null or undefined
			assertParamExists('getSongDataByVariantGuid', 'guid', guid)
			const localVarPath = `/song/ofvariant/{guid}`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (guid !== undefined) {
				localVarQueryParameter['guid'] = guid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSongListOfUser: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/song/my`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSongsCount: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/song/count`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} alias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVariantDataByAlias: async (
			alias: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'alias' is not null or undefined
			assertParamExists('getVariantDataByAlias', 'alias', alias)
			const localVarPath = `/one/variantdatabyalias`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (alias !== undefined) {
				localVarQueryParameter['alias'] = alias
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} alias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVariantFromAlias: async (
			alias: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'alias' is not null or undefined
			assertParamExists('getVariantFromAlias', 'alias', alias)
			const localVarPath = `/song/alias/variant/{alias}`.replace(
				`{${'alias'}}`,
				encodeURIComponent(String(alias))
			)
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
		 * @summary
		 * @param {string} [searchString]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		searchGlobalSongsInPopup: async (
			searchString?: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/song/teampopupglobalsongssearch`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (searchString !== undefined) {
				localVarQueryParameter['searchString'] = searchString
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
		 * @summary
		 * @param {string} [searchString]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		searchMySongsInPopup: async (
			searchString?: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/song/teampopupmysongssearch`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (searchString !== undefined) {
				localVarQueryParameter['searchString'] = searchString
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * SongGettingApi - functional programming interface
 * @export
 */
export const SongGettingApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		SongGettingApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getBasicPackDataByPackGuid(
			packGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<BasicVariantPackDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getBasicPackDataByPackGuid(
					packGuid,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.getBasicPackDataByPackGuid']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} searchKey
		 * @param {number} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getBySearch(
			searchKey: string,
			page?: number,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<BasicVariantPackDto>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getBySearch(
				searchKey,
				page,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.getBySearch']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getLastAdded(
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<BasicVariantPackDto>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getLastAdded(
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.getLastAdded']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {number} [page]
		 * @param {number} [perPage]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getList(
			page?: number,
			perPage?: number,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<GetListSongData>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getList(
				page,
				perPage,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.getList']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getListSongCount(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getListSongCount(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.getListSongCount']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} url
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getPublicSongBySource(
			url: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetPackAliasFromSourceUrlOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getPublicSongBySource(url, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.getPublicSongBySource']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getRandom(
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetRandomVariantOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getRandom(
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.getRandom']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getRecommendedSongs(
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetRecommendedSongsOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getRecommendedSongs(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.getRecommendedSongs']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getSitemapList(
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<GetListSongData>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getSitemapList(
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.getSitemapList']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} guid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getSongDataByGuid(
			guid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BasicSongDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getSongDataByGuid(guid, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.getSongDataByGuid']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} guid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getSongDataByVariantGuid(
			guid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetSongDataOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getSongDataByVariantGuid(guid, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.getSongDataByVariantGuid']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getSongListOfUser(
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetVariantsOfUserOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getSongListOfUser(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.getSongListOfUser']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getSongsCount(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getSongsCount(
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.getSongsCount']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} alias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getVariantDataByAlias(
			alias: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetVariantDataOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getVariantDataByAlias(alias, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.getVariantDataByAlias']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} alias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getVariantFromAlias(
			alias: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getVariantFromAlias(alias, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.getVariantFromAlias']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
		 * @summary
		 * @param {string} [searchString]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async searchGlobalSongsInPopup(
			searchString?: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetGlobalSongsOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.searchGlobalSongsInPopup(
					searchString,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.searchGlobalSongsInPopup']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
		 * @summary
		 * @param {string} [searchString]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async searchMySongsInPopup(
			searchString?: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetGlobalSongsOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.searchMySongsInPopup(
					searchString,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongGettingApi.searchMySongsInPopup']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * SongGettingApi - factory interface
 * @export
 */
export const SongGettingApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SongGettingApiFp(configuration)
	return {
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBasicPackDataByPackGuid(
			packGuid: string,
			options?: any
		): AxiosPromise<BasicVariantPackDto> {
			return localVarFp
				.getBasicPackDataByPackGuid(packGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} searchKey
		 * @param {number} [page]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getBySearch(
			searchKey: string,
			page?: number,
			options?: any
		): AxiosPromise<Array<BasicVariantPackDto>> {
			return localVarFp
				.getBySearch(searchKey, page, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getLastAdded(options?: any): AxiosPromise<Array<BasicVariantPackDto>> {
			return localVarFp
				.getLastAdded(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {number} [page]
		 * @param {number} [perPage]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getList(
			page?: number,
			perPage?: number,
			options?: any
		): AxiosPromise<Array<GetListSongData>> {
			return localVarFp
				.getList(page, perPage, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getListSongCount(options?: any): AxiosPromise<number> {
			return localVarFp
				.getListSongCount(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} url
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPublicSongBySource(
			url: string,
			options?: any
		): AxiosPromise<GetPackAliasFromSourceUrlOutDto> {
			return localVarFp
				.getPublicSongBySource(url, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRandom(options?: any): AxiosPromise<GetRandomVariantOutDto> {
			return localVarFp
				.getRandom(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRecommendedSongs(
			options?: any
		): AxiosPromise<GetRecommendedSongsOutDto> {
			return localVarFp
				.getRecommendedSongs(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSitemapList(options?: any): AxiosPromise<Array<GetListSongData>> {
			return localVarFp
				.getSitemapList(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} guid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSongDataByGuid(guid: string, options?: any): AxiosPromise<BasicSongDto> {
			return localVarFp
				.getSongDataByGuid(guid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} guid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSongDataByVariantGuid(
			guid: string,
			options?: any
		): AxiosPromise<GetSongDataOutDto> {
			return localVarFp
				.getSongDataByVariantGuid(guid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSongListOfUser(options?: any): AxiosPromise<GetVariantsOfUserOutDto> {
			return localVarFp
				.getSongListOfUser(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getSongsCount(options?: any): AxiosPromise<number> {
			return localVarFp
				.getSongsCount(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} alias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVariantDataByAlias(
			alias: string,
			options?: any
		): AxiosPromise<GetVariantDataOutDto> {
			return localVarFp
				.getVariantDataByAlias(alias, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} alias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getVariantFromAlias(alias: string, options?: any): AxiosPromise<string> {
			return localVarFp
				.getVariantFromAlias(alias, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
		 * @summary
		 * @param {string} [searchString]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		searchGlobalSongsInPopup(
			searchString?: string,
			options?: any
		): AxiosPromise<GetGlobalSongsOutDto> {
			return localVarFp
				.searchGlobalSongsInPopup(searchString, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
		 * @summary
		 * @param {string} [searchString]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		searchMySongsInPopup(
			searchString?: string,
			options?: any
		): AxiosPromise<GetGlobalSongsOutDto> {
			return localVarFp
				.searchMySongsInPopup(searchString, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * SongGettingApi - object-oriented interface
 * @export
 * @class SongGettingApi
 * @extends {BaseAPI}
 */
export class SongGettingApi extends BaseAPI {
	/**
	 *
	 * @param {string} packGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public getBasicPackDataByPackGuid(
		packGuid: string,
		options?: RawAxiosRequestConfig
	) {
		return SongGettingApiFp(this.configuration)
			.getBasicPackDataByPackGuid(packGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} searchKey
	 * @param {number} [page]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public getBySearch(
		searchKey: string,
		page?: number,
		options?: RawAxiosRequestConfig
	) {
		return SongGettingApiFp(this.configuration)
			.getBySearch(searchKey, page, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public getLastAdded(options?: RawAxiosRequestConfig) {
		return SongGettingApiFp(this.configuration)
			.getLastAdded(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {number} [page]
	 * @param {number} [perPage]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public getList(
		page?: number,
		perPage?: number,
		options?: RawAxiosRequestConfig
	) {
		return SongGettingApiFp(this.configuration)
			.getList(page, perPage, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public getListSongCount(options?: RawAxiosRequestConfig) {
		return SongGettingApiFp(this.configuration)
			.getListSongCount(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} url
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public getPublicSongBySource(url: string, options?: RawAxiosRequestConfig) {
		return SongGettingApiFp(this.configuration)
			.getPublicSongBySource(url, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public getRandom(options?: RawAxiosRequestConfig) {
		return SongGettingApiFp(this.configuration)
			.getRandom(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public getRecommendedSongs(options?: RawAxiosRequestConfig) {
		return SongGettingApiFp(this.configuration)
			.getRecommendedSongs(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public getSitemapList(options?: RawAxiosRequestConfig) {
		return SongGettingApiFp(this.configuration)
			.getSitemapList(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} guid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public getSongDataByGuid(guid: string, options?: RawAxiosRequestConfig) {
		return SongGettingApiFp(this.configuration)
			.getSongDataByGuid(guid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} guid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public getSongDataByVariantGuid(
		guid: string,
		options?: RawAxiosRequestConfig
	) {
		return SongGettingApiFp(this.configuration)
			.getSongDataByVariantGuid(guid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public getSongListOfUser(options?: RawAxiosRequestConfig) {
		return SongGettingApiFp(this.configuration)
			.getSongListOfUser(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public getSongsCount(options?: RawAxiosRequestConfig) {
		return SongGettingApiFp(this.configuration)
			.getSongsCount(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} alias
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public getVariantDataByAlias(alias: string, options?: RawAxiosRequestConfig) {
		return SongGettingApiFp(this.configuration)
			.getVariantDataByAlias(alias, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} alias
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public getVariantFromAlias(alias: string, options?: RawAxiosRequestConfig) {
		return SongGettingApiFp(this.configuration)
			.getVariantFromAlias(alias, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
	 * @summary
	 * @param {string} [searchString]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public searchGlobalSongsInPopup(
		searchString?: string,
		options?: RawAxiosRequestConfig
	) {
		return SongGettingApiFp(this.configuration)
			.searchGlobalSongsInPopup(searchString, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Endpoint for popup song search gloal songs I not support paging, but it return constant count of songs
	 * @summary
	 * @param {string} [searchString]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongGettingApi
	 */
	public searchMySongsInPopup(
		searchString?: string,
		options?: RawAxiosRequestConfig
	) {
		return SongGettingApiFp(this.configuration)
			.searchMySongsInPopup(searchString, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * SongManagementApi - axios parameter creator
 * @export
 */
export const SongManagementApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addAllPacksToFindFamily: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/song-merging/addallpackstofindfamilyqueue`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Add all packs without language to generate
		 * @summary
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addAllPacksToGenerate: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/pack/language/queue/addAllPacksToGenerate`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Add all packs without language to generate
		 * @summary
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addAllPacksToGenerate_1: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/pack/gg-filter/queue/addAllPacksToGenerate`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {AddMediaToPackInDto} addMediaToPackInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addMediaToPack: async (
			addMediaToPackInDto: AddMediaToPackInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'addMediaToPackInDto' is not null or undefined
			assertParamExists(
				'addMediaToPack',
				'addMediaToPackInDto',
				addMediaToPackInDto
			)
			const localVarPath = `/addMediaToPack`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				addMediaToPackInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addPackToFindFamily: async (
			packGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('addPackToFindFamily', 'packGuid', packGuid)
			const localVarPath = `/song-merging/addpacktofindfamilyqueue`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (packGuid !== undefined) {
				localVarQueryParameter['packGuid'] = packGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addPackToGenerate: async (
			packGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('addPackToGenerate', 'packGuid', packGuid)
			const localVarPath = `/pack/language/queue/addpacktogenerate`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (packGuid !== undefined) {
				localVarQueryParameter['packGuid'] = packGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addPackToGenerate_2: async (
			packGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('addPackToGenerate_2', 'packGuid', packGuid)
			const localVarPath = `/pack/gg-filter/queue/addpacktogenerate`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (packGuid !== undefined) {
				localVarQueryParameter['packGuid'] = packGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Auto find family for pack and merge to family
		 * @summary
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		autoFindFamily: async (
			packGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('autoFindFamily', 'packGuid', packGuid)
			const localVarPath = `/song-merging/autoFindFamily`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (packGuid !== undefined) {
				localVarQueryParameter['packGuid'] = packGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {CompareInDto} compareInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		comparePacks: async (
			compareInDto: CompareInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'compareInDto' is not null or undefined
			assertParamExists('comparePacks', 'compareInDto', compareInDto)
			const localVarPath = `/song-merging/compare`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				compareInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {MergeFamiliesInDto} mergeFamiliesInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		mergeFamilies: async (
			mergeFamiliesInDto: MergeFamiliesInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'mergeFamiliesInDto' is not null or undefined
			assertParamExists(
				'mergeFamilies',
				'mergeFamiliesInDto',
				mergeFamiliesInDto
			)
			const localVarPath = `/song-merging/mergeFamilies`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				mergeFamiliesInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {MovePacksToFamilyInDto} movePacksToFamilyInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		movePacksToFamily: async (
			movePacksToFamilyInDto: MovePacksToFamilyInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'movePacksToFamilyInDto' is not null or undefined
			assertParamExists(
				'movePacksToFamily',
				'movePacksToFamilyInDto',
				movePacksToFamilyInDto
			)
			const localVarPath = `/song-merging/movePacksToFamily`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				movePacksToFamilyInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {RemoveMediaToPackInDto} removeMediaToPackInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removeMediaFromPack: async (
			removeMediaToPackInDto: RemoveMediaToPackInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'removeMediaToPackInDto' is not null or undefined
			assertParamExists(
				'removeMediaFromPack',
				'removeMediaToPackInDto',
				removeMediaToPackInDto
			)
			const localVarPath = `/removeMediaFromPack`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				removeMediaToPackInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 * Separates all songs - creates a new family for each pack This will give each song its own unique family
		 * @summary
		 * @param {object} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		separateAllSongs: async (
			body: object,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'body' is not null or undefined
			assertParamExists('separateAllSongs', 'body', body)
			const localVarPath = `/song-merging/separateAllSongs`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				body,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {boolean} status
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		setFilterStatusForPack: async (
			packGuid: string,
			status: boolean,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('setFilterStatusForPack', 'packGuid', packGuid)
			// verify required parameter 'status' is not null or undefined
			assertParamExists('setFilterStatusForPack', 'status', status)
			const localVarPath = `/songs/filter/setFilterStatusForPack`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (packGuid !== undefined) {
				localVarQueryParameter['packGuid'] = packGuid
			}

			if (status !== undefined) {
				localVarQueryParameter['status'] = status
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		setFilterStatusToAutoForPack: async (
			packGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('setFilterStatusToAutoForPack', 'packGuid', packGuid)
			const localVarPath = `/songs/filter/setFilterStatusToAutoForPack`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (packGuid !== undefined) {
				localVarQueryParameter['packGuid'] = packGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {SetPackTranslationTypeInDto} setPackTranslationTypeInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		setTranslationType: async (
			setPackTranslationTypeInDto: SetPackTranslationTypeInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'setPackTranslationTypeInDto' is not null or undefined
			assertParamExists(
				'setTranslationType',
				'setPackTranslationTypeInDto',
				setPackTranslationTypeInDto
			)
			const localVarPath = `/song/pack-setting/setTranslationType`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				setPackTranslationTypeInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * SongManagementApi - functional programming interface
 * @export
 */
export const SongManagementApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		SongManagementApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addAllPacksToFindFamily(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addAllPacksToFindFamily(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.addAllPacksToFindFamily']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * Add all packs without language to generate
		 * @summary
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addAllPacksToGenerate(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addAllPacksToGenerate(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.addAllPacksToGenerate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * Add all packs without language to generate
		 * @summary
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addAllPacksToGenerate_1(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addAllPacksToGenerate_1(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.addAllPacksToGenerate_1']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {AddMediaToPackInDto} addMediaToPackInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addMediaToPack(
			addMediaToPackInDto: AddMediaToPackInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.addMediaToPack(
				addMediaToPackInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.addMediaToPack']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addPackToFindFamily(
			packGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addPackToFindFamily(packGuid, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.addPackToFindFamily']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addPackToGenerate(
			packGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addPackToGenerate(packGuid, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.addPackToGenerate']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addPackToGenerate_2(
			packGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addPackToGenerate_2(packGuid, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.addPackToGenerate_2']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * Auto find family for pack and merge to family
		 * @summary
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async autoFindFamily(
			packGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.autoFindFamily(
				packGuid,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.autoFindFamily']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {CompareInDto} compareInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async comparePacks(
			compareInDto: CompareInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.comparePacks(
				compareInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.comparePacks']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {MergeFamiliesInDto} mergeFamiliesInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async mergeFamilies(
			mergeFamiliesInDto: MergeFamiliesInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.mergeFamilies(
				mergeFamiliesInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.mergeFamilies']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {MovePacksToFamilyInDto} movePacksToFamilyInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async movePacksToFamily(
			movePacksToFamilyInDto: MovePacksToFamilyInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.movePacksToFamily(
					movePacksToFamilyInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.movePacksToFamily']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {RemoveMediaToPackInDto} removeMediaToPackInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async removeMediaFromPack(
			removeMediaToPackInDto: RemoveMediaToPackInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.removeMediaFromPack(
					removeMediaToPackInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.removeMediaFromPack']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 * Separates all songs - creates a new family for each pack This will give each song its own unique family
		 * @summary
		 * @param {object} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async separateAllSongs(
			body: object,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.separateAllSongs(body, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.separateAllSongs']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {boolean} status
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async setFilterStatusForPack(
			packGuid: string,
			status: boolean,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.setFilterStatusForPack(
					packGuid,
					status,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.setFilterStatusForPack']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async setFilterStatusToAutoForPack(
			packGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.setFilterStatusToAutoForPack(
					packGuid,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.setFilterStatusToAutoForPack']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {SetPackTranslationTypeInDto} setPackTranslationTypeInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async setTranslationType(
			setPackTranslationTypeInDto: SetPackTranslationTypeInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.setTranslationType(
					setPackTranslationTypeInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongManagementApi.setTranslationType']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * SongManagementApi - factory interface
 * @export
 */
export const SongManagementApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SongManagementApiFp(configuration)
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addAllPacksToFindFamily(options?: any): AxiosPromise<Array<string>> {
			return localVarFp
				.addAllPacksToFindFamily(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Add all packs without language to generate
		 * @summary
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addAllPacksToGenerate(options?: any): AxiosPromise<Array<string>> {
			return localVarFp
				.addAllPacksToGenerate(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Add all packs without language to generate
		 * @summary
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addAllPacksToGenerate_1(options?: any): AxiosPromise<Array<string>> {
			return localVarFp
				.addAllPacksToGenerate_1(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {AddMediaToPackInDto} addMediaToPackInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addMediaToPack(
			addMediaToPackInDto: AddMediaToPackInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.addMediaToPack(addMediaToPackInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addPackToFindFamily(packGuid: string, options?: any): AxiosPromise<string> {
			return localVarFp
				.addPackToFindFamily(packGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addPackToGenerate(packGuid: string, options?: any): AxiosPromise<string> {
			return localVarFp
				.addPackToGenerate(packGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addPackToGenerate_2(packGuid: string, options?: any): AxiosPromise<string> {
			return localVarFp
				.addPackToGenerate_2(packGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Auto find family for pack and merge to family
		 * @summary
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		autoFindFamily(packGuid: string, options?: any): AxiosPromise<string> {
			return localVarFp
				.autoFindFamily(packGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {CompareInDto} compareInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		comparePacks(
			compareInDto: CompareInDto,
			options?: any
		): AxiosPromise<object> {
			return localVarFp
				.comparePacks(compareInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {MergeFamiliesInDto} mergeFamiliesInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		mergeFamilies(
			mergeFamiliesInDto: MergeFamiliesInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.mergeFamilies(mergeFamiliesInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {MovePacksToFamilyInDto} movePacksToFamilyInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		movePacksToFamily(
			movePacksToFamilyInDto: MovePacksToFamilyInDto,
			options?: any
		): AxiosPromise<object> {
			return localVarFp
				.movePacksToFamily(movePacksToFamilyInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {RemoveMediaToPackInDto} removeMediaToPackInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removeMediaFromPack(
			removeMediaToPackInDto: RemoveMediaToPackInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.removeMediaFromPack(removeMediaToPackInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 * Separates all songs - creates a new family for each pack This will give each song its own unique family
		 * @summary
		 * @param {object} body
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		separateAllSongs(body: object, options?: any): AxiosPromise<void> {
			return localVarFp
				.separateAllSongs(body, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {boolean} status
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		setFilterStatusForPack(
			packGuid: string,
			status: boolean,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.setFilterStatusForPack(packGuid, status, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		setFilterStatusToAutoForPack(
			packGuid: string,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.setFilterStatusToAutoForPack(packGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {SetPackTranslationTypeInDto} setPackTranslationTypeInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		setTranslationType(
			setPackTranslationTypeInDto: SetPackTranslationTypeInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.setTranslationType(setPackTranslationTypeInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * SongManagementApi - object-oriented interface
 * @export
 * @class SongManagementApi
 * @extends {BaseAPI}
 */
export class SongManagementApi extends BaseAPI {
	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public addAllPacksToFindFamily(options?: RawAxiosRequestConfig) {
		return SongManagementApiFp(this.configuration)
			.addAllPacksToFindFamily(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Add all packs without language to generate
	 * @summary
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public addAllPacksToGenerate(options?: RawAxiosRequestConfig) {
		return SongManagementApiFp(this.configuration)
			.addAllPacksToGenerate(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Add all packs without language to generate
	 * @summary
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public addAllPacksToGenerate_1(options?: RawAxiosRequestConfig) {
		return SongManagementApiFp(this.configuration)
			.addAllPacksToGenerate_1(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {AddMediaToPackInDto} addMediaToPackInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public addMediaToPack(
		addMediaToPackInDto: AddMediaToPackInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongManagementApiFp(this.configuration)
			.addMediaToPack(addMediaToPackInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} packGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public addPackToFindFamily(
		packGuid: string,
		options?: RawAxiosRequestConfig
	) {
		return SongManagementApiFp(this.configuration)
			.addPackToFindFamily(packGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} packGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public addPackToGenerate(packGuid: string, options?: RawAxiosRequestConfig) {
		return SongManagementApiFp(this.configuration)
			.addPackToGenerate(packGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} packGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public addPackToGenerate_2(
		packGuid: string,
		options?: RawAxiosRequestConfig
	) {
		return SongManagementApiFp(this.configuration)
			.addPackToGenerate_2(packGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Auto find family for pack and merge to family
	 * @summary
	 * @param {string} packGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public autoFindFamily(packGuid: string, options?: RawAxiosRequestConfig) {
		return SongManagementApiFp(this.configuration)
			.autoFindFamily(packGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {CompareInDto} compareInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public comparePacks(
		compareInDto: CompareInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongManagementApiFp(this.configuration)
			.comparePacks(compareInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {MergeFamiliesInDto} mergeFamiliesInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public mergeFamilies(
		mergeFamiliesInDto: MergeFamiliesInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongManagementApiFp(this.configuration)
			.mergeFamilies(mergeFamiliesInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {MovePacksToFamilyInDto} movePacksToFamilyInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public movePacksToFamily(
		movePacksToFamilyInDto: MovePacksToFamilyInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongManagementApiFp(this.configuration)
			.movePacksToFamily(movePacksToFamilyInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {RemoveMediaToPackInDto} removeMediaToPackInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public removeMediaFromPack(
		removeMediaToPackInDto: RemoveMediaToPackInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongManagementApiFp(this.configuration)
			.removeMediaFromPack(removeMediaToPackInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 * Separates all songs - creates a new family for each pack This will give each song its own unique family
	 * @summary
	 * @param {object} body
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public separateAllSongs(body: object, options?: RawAxiosRequestConfig) {
		return SongManagementApiFp(this.configuration)
			.separateAllSongs(body, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} packGuid
	 * @param {boolean} status
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public setFilterStatusForPack(
		packGuid: string,
		status: boolean,
		options?: RawAxiosRequestConfig
	) {
		return SongManagementApiFp(this.configuration)
			.setFilterStatusForPack(packGuid, status, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} packGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public setFilterStatusToAutoForPack(
		packGuid: string,
		options?: RawAxiosRequestConfig
	) {
		return SongManagementApiFp(this.configuration)
			.setFilterStatusToAutoForPack(packGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {SetPackTranslationTypeInDto} setPackTranslationTypeInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongManagementApi
	 */
	public setTranslationType(
		setPackTranslationTypeInDto: SetPackTranslationTypeInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongManagementApiFp(this.configuration)
			.setTranslationType(setPackTranslationTypeInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * SongNotesApi - axios parameter creator
 * @export
 */
export const SongNotesApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {AddNoteToVariantInDto} addNoteToVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addNoteToVariant: async (
			addNoteToVariantInDto: AddNoteToVariantInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'addNoteToVariantInDto' is not null or undefined
			assertParamExists(
				'addNoteToVariant',
				'addNoteToVariantInDto',
				addNoteToVariantInDto
			)
			const localVarPath = `/song/variant/notes/add`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				addNoteToVariantInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {DeleteNoteInDto} deleteNoteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteNote: async (
			deleteNoteInDto: DeleteNoteInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'deleteNoteInDto' is not null or undefined
			assertParamExists('deleteNote', 'deleteNoteInDto', deleteNoteInDto)
			const localVarPath = `/song/variant/notes`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				deleteNoteInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {UpdateNoteInDto} updateNoteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		editNote: async (
			updateNoteInDto: UpdateNoteInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'updateNoteInDto' is not null or undefined
			assertParamExists('editNote', 'updateNoteInDto', updateNoteInDto)
			const localVarPath = `/song/variant/notes/edit`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				updateNoteInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getNotesOfVariantAndUser: async (
			packGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('getNotesOfVariantAndUser', 'packGuid', packGuid)
			const localVarPath = `/song/variant/notes`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (packGuid !== undefined) {
				localVarQueryParameter['packGuid'] = packGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * SongNotesApi - functional programming interface
 * @export
 */
export const SongNotesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = SongNotesApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {AddNoteToVariantInDto} addNoteToVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addNoteToVariant(
			addNoteToVariantInDto: AddNoteToVariantInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addNoteToVariant(
					addNoteToVariantInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongNotesApi.addNoteToVariant']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {DeleteNoteInDto} deleteNoteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteNote(
			deleteNoteInDto: DeleteNoteInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNote(
				deleteNoteInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongNotesApi.deleteNote']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {UpdateNoteInDto} updateNoteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async editNote(
			updateNoteInDto: UpdateNoteInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.editNote(
				updateNoteInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongNotesApi.editNote']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getNotesOfVariantAndUser(
			packGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetNotesOfVariantOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getNotesOfVariantAndUser(
					packGuid,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongNotesApi.getNotesOfVariantAndUser']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * SongNotesApi - factory interface
 * @export
 */
export const SongNotesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SongNotesApiFp(configuration)
	return {
		/**
		 *
		 * @param {AddNoteToVariantInDto} addNoteToVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addNoteToVariant(
			addNoteToVariantInDto: AddNoteToVariantInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.addNoteToVariant(addNoteToVariantInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {DeleteNoteInDto} deleteNoteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteNote(
			deleteNoteInDto: DeleteNoteInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.deleteNote(deleteNoteInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {UpdateNoteInDto} updateNoteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		editNote(
			updateNoteInDto: UpdateNoteInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.editNote(updateNoteInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getNotesOfVariantAndUser(
			packGuid: string,
			options?: any
		): AxiosPromise<GetNotesOfVariantOutDto> {
			return localVarFp
				.getNotesOfVariantAndUser(packGuid, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * SongNotesApi - object-oriented interface
 * @export
 * @class SongNotesApi
 * @extends {BaseAPI}
 */
export class SongNotesApi extends BaseAPI {
	/**
	 *
	 * @param {AddNoteToVariantInDto} addNoteToVariantInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongNotesApi
	 */
	public addNoteToVariant(
		addNoteToVariantInDto: AddNoteToVariantInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongNotesApiFp(this.configuration)
			.addNoteToVariant(addNoteToVariantInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {DeleteNoteInDto} deleteNoteInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongNotesApi
	 */
	public deleteNote(
		deleteNoteInDto: DeleteNoteInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongNotesApiFp(this.configuration)
			.deleteNote(deleteNoteInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {UpdateNoteInDto} updateNoteInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongNotesApi
	 */
	public editNote(
		updateNoteInDto: UpdateNoteInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongNotesApiFp(this.configuration)
			.editNote(updateNoteInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} packGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongNotesApi
	 */
	public getNotesOfVariantAndUser(
		packGuid: string,
		options?: RawAxiosRequestConfig
	) {
		return SongNotesApiFp(this.configuration)
			.getNotesOfVariantAndUser(packGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * SongPublishingApi - axios parameter creator
 * @export
 */
export const SongPublishingApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {PostGetKeywordsInDto} postGetKeywordsInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		generateKeywords: async (
			postGetKeywordsInDto: PostGetKeywordsInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postGetKeywordsInDto' is not null or undefined
			assertParamExists(
				'generateKeywords',
				'postGetKeywordsInDto',
				postGetKeywordsInDto
			)
			const localVarPath = `/song/generatekeywords`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postGetKeywordsInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getApprovalPacks: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/song/getapprovalpacks`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {PostGetKeywordsInDto} postGetKeywordsInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getKeywords: async (
			postGetKeywordsInDto: PostGetKeywordsInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postGetKeywordsInDto' is not null or undefined
			assertParamExists(
				'getKeywords',
				'postGetKeywordsInDto',
				postGetKeywordsInDto
			)
			const localVarPath = `/song/getkeywords`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postGetKeywordsInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {PostPublishVariantInDto} postPublishVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		publishOfficialVariant: async (
			postPublishVariantInDto: PostPublishVariantInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postPublishVariantInDto' is not null or undefined
			assertParamExists(
				'publishOfficialVariant',
				'postPublishVariantInDto',
				postPublishVariantInDto
			)
			const localVarPath = `/song/publish-official`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postPublishVariantInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {PostPublishVariantInDto} postPublishVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		publishVariant: async (
			postPublishVariantInDto: PostPublishVariantInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postPublishVariantInDto' is not null or undefined
			assertParamExists(
				'publishVariant',
				'postPublishVariantInDto',
				postPublishVariantInDto
			)
			const localVarPath = `/song/publish`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postPublishVariantInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		rejectPublishApproval: async (
			postSendPackToApprovalInDto: PostSendPackToApprovalInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postSendPackToApprovalInDto' is not null or undefined
			assertParamExists(
				'rejectPublishApproval',
				'postSendPackToApprovalInDto',
				postSendPackToApprovalInDto
			)
			const localVarPath = `/song/rejectPublishApproval`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postSendPackToApprovalInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		sendPackToApproval: async (
			postSendPackToApprovalInDto: PostSendPackToApprovalInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postSendPackToApprovalInDto' is not null or undefined
			assertParamExists(
				'sendPackToApproval',
				'postSendPackToApprovalInDto',
				postSendPackToApprovalInDto
			)
			const localVarPath = `/song/sendpacktoapproval`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postSendPackToApprovalInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {PostPublishVariantInDto} postPublishVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		unpublishVariant: async (
			postPublishVariantInDto: PostPublishVariantInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postPublishVariantInDto' is not null or undefined
			assertParamExists(
				'unpublishVariant',
				'postPublishVariantInDto',
				postPublishVariantInDto
			)
			const localVarPath = `/song/unpublish`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postPublishVariantInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {PostVerifyVariantInDto} postVerifyVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		verifyVariant: async (
			postVerifyVariantInDto: PostVerifyVariantInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postVerifyVariantInDto' is not null or undefined
			assertParamExists(
				'verifyVariant',
				'postVerifyVariantInDto',
				postVerifyVariantInDto
			)
			const localVarPath = `/song/verifystatus`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postVerifyVariantInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * SongPublishingApi - functional programming interface
 * @export
 */
export const SongPublishingApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		SongPublishingApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {PostGetKeywordsInDto} postGetKeywordsInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async generateKeywords(
			postGetKeywordsInDto: PostGetKeywordsInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.generateKeywords(
					postGetKeywordsInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongPublishingApi.generateKeywords']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getApprovalPacks(
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<BasicVariantPackDto>>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getApprovalPacks(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongPublishingApi.getApprovalPacks']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {PostGetKeywordsInDto} postGetKeywordsInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getKeywords(
			postGetKeywordsInDto: PostGetKeywordsInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getKeywords(
				postGetKeywordsInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongPublishingApi.getKeywords']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {PostPublishVariantInDto} postPublishVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async publishOfficialVariant(
			postPublishVariantInDto: PostPublishVariantInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.publishOfficialVariant(
					postPublishVariantInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongPublishingApi.publishOfficialVariant']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {PostPublishVariantInDto} postPublishVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async publishVariant(
			postPublishVariantInDto: PostPublishVariantInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.publishVariant(
				postPublishVariantInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongPublishingApi.publishVariant']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async rejectPublishApproval(
			postSendPackToApprovalInDto: PostSendPackToApprovalInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.rejectPublishApproval(
					postSendPackToApprovalInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongPublishingApi.rejectPublishApproval']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async sendPackToApproval(
			postSendPackToApprovalInDto: PostSendPackToApprovalInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.sendPackToApproval(
					postSendPackToApprovalInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongPublishingApi.sendPackToApproval']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {PostPublishVariantInDto} postPublishVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async unpublishVariant(
			postPublishVariantInDto: PostPublishVariantInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.unpublishVariant(
					postPublishVariantInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongPublishingApi.unpublishVariant']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {PostVerifyVariantInDto} postVerifyVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async verifyVariant(
			postVerifyVariantInDto: PostVerifyVariantInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SongVariant>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.verifyVariant(
				postVerifyVariantInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongPublishingApi.verifyVariant']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * SongPublishingApi - factory interface
 * @export
 */
export const SongPublishingApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SongPublishingApiFp(configuration)
	return {
		/**
		 *
		 * @param {PostGetKeywordsInDto} postGetKeywordsInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		generateKeywords(
			postGetKeywordsInDto: PostGetKeywordsInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.generateKeywords(postGetKeywordsInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getApprovalPacks(options?: any): AxiosPromise<Array<BasicVariantPackDto>> {
			return localVarFp
				.getApprovalPacks(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {PostGetKeywordsInDto} postGetKeywordsInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getKeywords(
			postGetKeywordsInDto: PostGetKeywordsInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.getKeywords(postGetKeywordsInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {PostPublishVariantInDto} postPublishVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		publishOfficialVariant(
			postPublishVariantInDto: PostPublishVariantInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.publishOfficialVariant(postPublishVariantInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {PostPublishVariantInDto} postPublishVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		publishVariant(
			postPublishVariantInDto: PostPublishVariantInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.publishVariant(postPublishVariantInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		rejectPublishApproval(
			postSendPackToApprovalInDto: PostSendPackToApprovalInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.rejectPublishApproval(postSendPackToApprovalInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		sendPackToApproval(
			postSendPackToApprovalInDto: PostSendPackToApprovalInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.sendPackToApproval(postSendPackToApprovalInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {PostPublishVariantInDto} postPublishVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		unpublishVariant(
			postPublishVariantInDto: PostPublishVariantInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.unpublishVariant(postPublishVariantInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {PostVerifyVariantInDto} postVerifyVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		verifyVariant(
			postVerifyVariantInDto: PostVerifyVariantInDto,
			options?: any
		): AxiosPromise<SongVariant> {
			return localVarFp
				.verifyVariant(postVerifyVariantInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * SongPublishingApi - object-oriented interface
 * @export
 * @class SongPublishingApi
 * @extends {BaseAPI}
 */
export class SongPublishingApi extends BaseAPI {
	/**
	 *
	 * @param {PostGetKeywordsInDto} postGetKeywordsInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongPublishingApi
	 */
	public generateKeywords(
		postGetKeywordsInDto: PostGetKeywordsInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongPublishingApiFp(this.configuration)
			.generateKeywords(postGetKeywordsInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongPublishingApi
	 */
	public getApprovalPacks(options?: RawAxiosRequestConfig) {
		return SongPublishingApiFp(this.configuration)
			.getApprovalPacks(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {PostGetKeywordsInDto} postGetKeywordsInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongPublishingApi
	 */
	public getKeywords(
		postGetKeywordsInDto: PostGetKeywordsInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongPublishingApiFp(this.configuration)
			.getKeywords(postGetKeywordsInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {PostPublishVariantInDto} postPublishVariantInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongPublishingApi
	 */
	public publishOfficialVariant(
		postPublishVariantInDto: PostPublishVariantInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongPublishingApiFp(this.configuration)
			.publishOfficialVariant(postPublishVariantInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {PostPublishVariantInDto} postPublishVariantInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongPublishingApi
	 */
	public publishVariant(
		postPublishVariantInDto: PostPublishVariantInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongPublishingApiFp(this.configuration)
			.publishVariant(postPublishVariantInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongPublishingApi
	 */
	public rejectPublishApproval(
		postSendPackToApprovalInDto: PostSendPackToApprovalInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongPublishingApiFp(this.configuration)
			.rejectPublishApproval(postSendPackToApprovalInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {PostSendPackToApprovalInDto} postSendPackToApprovalInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongPublishingApi
	 */
	public sendPackToApproval(
		postSendPackToApprovalInDto: PostSendPackToApprovalInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongPublishingApiFp(this.configuration)
			.sendPackToApproval(postSendPackToApprovalInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {PostPublishVariantInDto} postPublishVariantInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongPublishingApi
	 */
	public unpublishVariant(
		postPublishVariantInDto: PostPublishVariantInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongPublishingApiFp(this.configuration)
			.unpublishVariant(postPublishVariantInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {PostVerifyVariantInDto} postVerifyVariantInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongPublishingApi
	 */
	public verifyVariant(
		postVerifyVariantInDto: PostVerifyVariantInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongPublishingApiFp(this.configuration)
			.verifyVariant(postVerifyVariantInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * SongSearchingApi - axios parameter creator
 * @export
 */
export const SongSearchingApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} searchKey
		 * @param {number} [page]
		 * @param {boolean} [onlyWithChords]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		search: async (
			searchKey: string,
			page?: number,
			onlyWithChords?: boolean,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'searchKey' is not null or undefined
			assertParamExists('search', 'searchKey', searchKey)
			const localVarPath = `/song/searching/search`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (searchKey !== undefined) {
				localVarQueryParameter['searchKey'] = searchKey
			}

			if (page !== undefined) {
				localVarQueryParameter['page'] = page
			}

			if (onlyWithChords !== undefined) {
				localVarQueryParameter['onlyWithChords'] = onlyWithChords
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * SongSearchingApi - functional programming interface
 * @export
 */
export const SongSearchingApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		SongSearchingApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {string} searchKey
		 * @param {number} [page]
		 * @param {boolean} [onlyWithChords]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async search(
			searchKey: string,
			page?: number,
			onlyWithChords?: boolean,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<Array<SearchSongPacksDto>>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.search(
				searchKey,
				page,
				onlyWithChords,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongSearchingApi.search']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * SongSearchingApi - factory interface
 * @export
 */
export const SongSearchingApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SongSearchingApiFp(configuration)
	return {
		/**
		 *
		 * @param {string} searchKey
		 * @param {number} [page]
		 * @param {boolean} [onlyWithChords]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		search(
			searchKey: string,
			page?: number,
			onlyWithChords?: boolean,
			options?: any
		): AxiosPromise<Array<SearchSongPacksDto>> {
			return localVarFp
				.search(searchKey, page, onlyWithChords, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * SongSearchingApi - object-oriented interface
 * @export
 * @class SongSearchingApi
 * @extends {BaseAPI}
 */
export class SongSearchingApi extends BaseAPI {
	/**
	 *
	 * @param {string} searchKey
	 * @param {number} [page]
	 * @param {boolean} [onlyWithChords]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongSearchingApi
	 */
	public search(
		searchKey: string,
		page?: number,
		onlyWithChords?: boolean,
		options?: RawAxiosRequestConfig
	) {
		return SongSearchingApiFp(this.configuration)
			.search(searchKey, page, onlyWithChords, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * SongUserManagementApi - axios parameter creator
 * @export
 */
export const SongUserManagementApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addUserLikeToTranslation: async (
			addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'addUserLikeToTranslationInDto' is not null or undefined
			assertParamExists(
				'addUserLikeToTranslation',
				'addUserLikeToTranslationInDto',
				addUserLikeToTranslationInDto
			)
			const localVarPath = `/song/translation-like/add-user-like-to-translation`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				addUserLikeToTranslationInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUserLikes: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/song/translation-like/get-user-likes`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removeUserLikeFromTranslation: async (
			addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'addUserLikeToTranslationInDto' is not null or undefined
			assertParamExists(
				'removeUserLikeFromTranslation',
				'addUserLikeToTranslationInDto',
				addUserLikeToTranslationInDto
			)
			const localVarPath = `/song/translation-like/remove-user-like-from-translation`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				addUserLikeToTranslationInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * SongUserManagementApi - functional programming interface
 * @export
 */
export const SongUserManagementApiFp = function (
	configuration?: Configuration
) {
	const localVarAxiosParamCreator =
		SongUserManagementApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addUserLikeToTranslation(
			addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetUserTranslationLikesOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addUserLikeToTranslation(
					addUserLikeToTranslationInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongUserManagementApi.addUserLikeToTranslation']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getUserLikes(
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetUserTranslationLikesOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getUserLikes(
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongUserManagementApi.getUserLikes']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async removeUserLikeFromTranslation(
			addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetUserTranslationLikesOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.removeUserLikeFromTranslation(
					addUserLikeToTranslationInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap[
					'SongUserManagementApi.removeUserLikeFromTranslation'
				]?.[localVarOperationServerIndex]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * SongUserManagementApi - factory interface
 * @export
 */
export const SongUserManagementApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SongUserManagementApiFp(configuration)
	return {
		/**
		 *
		 * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addUserLikeToTranslation(
			addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto,
			options?: any
		): AxiosPromise<GetUserTranslationLikesOutDto> {
			return localVarFp
				.addUserLikeToTranslation(addUserLikeToTranslationInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getUserLikes(options?: any): AxiosPromise<GetUserTranslationLikesOutDto> {
			return localVarFp
				.getUserLikes(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removeUserLikeFromTranslation(
			addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto,
			options?: any
		): AxiosPromise<GetUserTranslationLikesOutDto> {
			return localVarFp
				.removeUserLikeFromTranslation(addUserLikeToTranslationInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * SongUserManagementApi - object-oriented interface
 * @export
 * @class SongUserManagementApi
 * @extends {BaseAPI}
 */
export class SongUserManagementApi extends BaseAPI {
	/**
	 *
	 * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongUserManagementApi
	 */
	public addUserLikeToTranslation(
		addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongUserManagementApiFp(this.configuration)
			.addUserLikeToTranslation(addUserLikeToTranslationInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongUserManagementApi
	 */
	public getUserLikes(options?: RawAxiosRequestConfig) {
		return SongUserManagementApiFp(this.configuration)
			.getUserLikes(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {AddUserLikeToTranslationInDto} addUserLikeToTranslationInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongUserManagementApi
	 */
	public removeUserLikeFromTranslation(
		addUserLikeToTranslationInDto: AddUserLikeToTranslationInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongUserManagementApiFp(this.configuration)
			.removeUserLikeFromTranslation(addUserLikeToTranslationInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * SongValidationApi - axios parameter creator
 * @export
 */
export const SongValidationApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		validateSheetDataAndTitle: async (
			postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'postValidateSheetDataAndTitleInDto' is not null or undefined
			assertParamExists(
				'validateSheetDataAndTitle',
				'postValidateSheetDataAndTitleInDto',
				postValidateSheetDataAndTitleInDto
			)
			const localVarPath = `/song/validate`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				postValidateSheetDataAndTitleInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * SongValidationApi - functional programming interface
 * @export
 */
export const SongValidationApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		SongValidationApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async validateSheetDataAndTitle(
			postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<ValidationResult>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.validateSheetDataAndTitle(
					postValidateSheetDataAndTitleInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['SongValidationApi.validateSheetDataAndTitle']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * SongValidationApi - factory interface
 * @export
 */
export const SongValidationApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = SongValidationApiFp(configuration)
	return {
		/**
		 *
		 * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		validateSheetDataAndTitle(
			postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto,
			options?: any
		): AxiosPromise<ValidationResult> {
			return localVarFp
				.validateSheetDataAndTitle(postValidateSheetDataAndTitleInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * SongValidationApi - object-oriented interface
 * @export
 * @class SongValidationApi
 * @extends {BaseAPI}
 */
export class SongValidationApi extends BaseAPI {
	/**
	 *
	 * @param {PostValidateSheetDataAndTitleInDto} postValidateSheetDataAndTitleInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof SongValidationApi
	 */
	public validateSheetDataAndTitle(
		postValidateSheetDataAndTitleInDto: PostValidateSheetDataAndTitleInDto,
		options?: RawAxiosRequestConfig
	) {
		return SongValidationApiFp(this.configuration)
			.validateSheetDataAndTitle(postValidateSheetDataAndTitleInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * TeamAddingApi - axios parameter creator
 * @export
 */
export const TeamAddingApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {CreateTeamInDto} createTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createNewTeam: async (
			createTeamInDto: CreateTeamInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'createTeamInDto' is not null or undefined
			assertParamExists('createNewTeam', 'createTeamInDto', createTeamInDto)
			const localVarPath = `/submodules/teams/create`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				createTeamInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * TeamAddingApi - functional programming interface
 * @export
 */
export const TeamAddingApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		TeamAddingApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {CreateTeamInDto} createTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createNewTeam(
			createTeamInDto: CreateTeamInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<CreateTeamOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createNewTeam(
				createTeamInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamAddingApi.createNewTeam']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * TeamAddingApi - factory interface
 * @export
 */
export const TeamAddingApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = TeamAddingApiFp(configuration)
	return {
		/**
		 *
		 * @param {CreateTeamInDto} createTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createNewTeam(
			createTeamInDto: CreateTeamInDto,
			options?: any
		): AxiosPromise<CreateTeamOutDto> {
			return localVarFp
				.createNewTeam(createTeamInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * TeamAddingApi - object-oriented interface
 * @export
 * @class TeamAddingApi
 * @extends {BaseAPI}
 */
export class TeamAddingApi extends BaseAPI {
	/**
	 *
	 * @param {CreateTeamInDto} createTeamInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamAddingApi
	 */
	public createNewTeam(
		createTeamInDto: CreateTeamInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamAddingApiFp(this.configuration)
			.createNewTeam(createTeamInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * TeamEditingApi - axios parameter creator
 * @export
 */
export const TeamEditingApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addPackToTeam: async (
			addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'addPackToTeamSelectionInDto' is not null or undefined
			assertParamExists(
				'addPackToTeam',
				'addPackToTeamSelectionInDto',
				addPackToTeamSelectionInDto
			)
			const localVarPath = `/submodules/teams/selection/add/pack`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				addPackToTeamSelectionInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {AttachPlaylistToTeamInDto} attachPlaylistToTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attachPlaylistToTeam: async (
			attachPlaylistToTeamInDto: AttachPlaylistToTeamInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'attachPlaylistToTeamInDto' is not null or undefined
			assertParamExists(
				'attachPlaylistToTeam',
				'attachPlaylistToTeamInDto',
				attachPlaylistToTeamInDto
			)
			const localVarPath = `/submodules/teams/selection/attachPlaylistToTeam`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				attachPlaylistToTeamInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {ChangeTeamInfoInDto} changeTeamInfoInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		changeTeamInfo: async (
			changeTeamInfoInDto: ChangeTeamInfoInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'changeTeamInfoInDto' is not null or undefined
			assertParamExists(
				'changeTeamInfo',
				'changeTeamInfoInDto',
				changeTeamInfoInDto
			)
			const localVarPath = `/submodules/teams/changeteaminfo`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				changeTeamInfoInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		changeTeamLogo: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/submodules/teams/changelogo`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {DeleteTeamInDto} deleteTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteTeam: async (
			deleteTeamInDto: DeleteTeamInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'deleteTeamInDto' is not null or undefined
			assertParamExists('deleteTeam', 'deleteTeamInDto', deleteTeamInDto)
			const localVarPath = `/submodules/teams/deleteteam`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				deleteTeamInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {EditPayloadInDto} editPayloadInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		editPayload: async (
			editPayloadInDto: EditPayloadInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'editPayloadInDto' is not null or undefined
			assertParamExists('editPayload', 'editPayloadInDto', editPayloadInDto)
			const localVarPath = `/submodules/teams/editpayload`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				editPayloadInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removePackFromTeam: async (
			addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'addPackToTeamSelectionInDto' is not null or undefined
			assertParamExists(
				'removePackFromTeam',
				'addPackToTeamSelectionInDto',
				addPackToTeamSelectionInDto
			)
			const localVarPath = `/submodules/teams/selection/remove/pack`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				addPackToTeamSelectionInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {RemoveTeamLogoInDto} removeTeamLogoInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removeTeamLogo: async (
			removeTeamLogoInDto: RemoveTeamLogoInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'removeTeamLogoInDto' is not null or undefined
			assertParamExists(
				'removeTeamLogo',
				'removeTeamLogoInDto',
				removeTeamLogoInDto
			)
			const localVarPath = `/submodules/teams/removeLogo`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				removeTeamLogoInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * TeamEditingApi - functional programming interface
 * @export
 */
export const TeamEditingApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		TeamEditingApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addPackToTeam(
			addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<PlaylistItemOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.addPackToTeam(
				addPackToTeamSelectionInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamEditingApi.addPackToTeam']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {AttachPlaylistToTeamInDto} attachPlaylistToTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async attachPlaylistToTeam(
			attachPlaylistToTeamInDto: AttachPlaylistToTeamInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.attachPlaylistToTeam(
					attachPlaylistToTeamInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamEditingApi.attachPlaylistToTeam']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {ChangeTeamInfoInDto} changeTeamInfoInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async changeTeamInfo(
			changeTeamInfoInDto: ChangeTeamInfoInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.changeTeamInfo(
				changeTeamInfoInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamEditingApi.changeTeamInfo']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async changeTeamLogo(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.changeTeamLogo(
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamEditingApi.changeTeamLogo']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {DeleteTeamInDto} deleteTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteTeam(
			deleteTeamInDto: DeleteTeamInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTeam(
				deleteTeamInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamEditingApi.deleteTeam']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {EditPayloadInDto} editPayloadInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async editPayload(
			editPayloadInDto: EditPayloadInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.editPayload(
				editPayloadInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamEditingApi.editPayload']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async removePackFromTeam(
			addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.removePackFromTeam(
					addPackToTeamSelectionInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamEditingApi.removePackFromTeam']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {RemoveTeamLogoInDto} removeTeamLogoInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async removeTeamLogo(
			removeTeamLogoInDto: RemoveTeamLogoInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.removeTeamLogo(
				removeTeamLogoInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamEditingApi.removeTeamLogo']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * TeamEditingApi - factory interface
 * @export
 */
export const TeamEditingApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = TeamEditingApiFp(configuration)
	return {
		/**
		 *
		 * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addPackToTeam(
			addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto,
			options?: any
		): AxiosPromise<PlaylistItemOutDto> {
			return localVarFp
				.addPackToTeam(addPackToTeamSelectionInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {AttachPlaylistToTeamInDto} attachPlaylistToTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		attachPlaylistToTeam(
			attachPlaylistToTeamInDto: AttachPlaylistToTeamInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.attachPlaylistToTeam(attachPlaylistToTeamInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {ChangeTeamInfoInDto} changeTeamInfoInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		changeTeamInfo(
			changeTeamInfoInDto: ChangeTeamInfoInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.changeTeamInfo(changeTeamInfoInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		changeTeamLogo(options?: any): AxiosPromise<void> {
			return localVarFp
				.changeTeamLogo(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {DeleteTeamInDto} deleteTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteTeam(
			deleteTeamInDto: DeleteTeamInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.deleteTeam(deleteTeamInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {EditPayloadInDto} editPayloadInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		editPayload(
			editPayloadInDto: EditPayloadInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.editPayload(editPayloadInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removePackFromTeam(
			addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.removePackFromTeam(addPackToTeamSelectionInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {RemoveTeamLogoInDto} removeTeamLogoInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		removeTeamLogo(
			removeTeamLogoInDto: RemoveTeamLogoInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.removeTeamLogo(removeTeamLogoInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * TeamEditingApi - object-oriented interface
 * @export
 * @class TeamEditingApi
 * @extends {BaseAPI}
 */
export class TeamEditingApi extends BaseAPI {
	/**
	 *
	 * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamEditingApi
	 */
	public addPackToTeam(
		addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamEditingApiFp(this.configuration)
			.addPackToTeam(addPackToTeamSelectionInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {AttachPlaylistToTeamInDto} attachPlaylistToTeamInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamEditingApi
	 */
	public attachPlaylistToTeam(
		attachPlaylistToTeamInDto: AttachPlaylistToTeamInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamEditingApiFp(this.configuration)
			.attachPlaylistToTeam(attachPlaylistToTeamInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {ChangeTeamInfoInDto} changeTeamInfoInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamEditingApi
	 */
	public changeTeamInfo(
		changeTeamInfoInDto: ChangeTeamInfoInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamEditingApiFp(this.configuration)
			.changeTeamInfo(changeTeamInfoInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamEditingApi
	 */
	public changeTeamLogo(options?: RawAxiosRequestConfig) {
		return TeamEditingApiFp(this.configuration)
			.changeTeamLogo(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {DeleteTeamInDto} deleteTeamInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamEditingApi
	 */
	public deleteTeam(
		deleteTeamInDto: DeleteTeamInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamEditingApiFp(this.configuration)
			.deleteTeam(deleteTeamInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {EditPayloadInDto} editPayloadInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamEditingApi
	 */
	public editPayload(
		editPayloadInDto: EditPayloadInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamEditingApiFp(this.configuration)
			.editPayload(editPayloadInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {AddPackToTeamSelectionInDto} addPackToTeamSelectionInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamEditingApi
	 */
	public removePackFromTeam(
		addPackToTeamSelectionInDto: AddPackToTeamSelectionInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamEditingApiFp(this.configuration)
			.removePackFromTeam(addPackToTeamSelectionInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {RemoveTeamLogoInDto} removeTeamLogoInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamEditingApi
	 */
	public removeTeamLogo(
		removeTeamLogoInDto: RemoveTeamLogoInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamEditingApiFp(this.configuration)
			.removeTeamLogo(removeTeamLogoInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * TeamEventsApi - axios parameter creator
 * @export
 */
export const TeamEventsApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {CreateTeamEventInDto} createTeamEventInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createEvent: async (
			createTeamEventInDto: CreateTeamEventInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'createTeamEventInDto' is not null or undefined
			assertParamExists(
				'createEvent',
				'createTeamEventInDto',
				createTeamEventInDto
			)
			const localVarPath = `/teams/events`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				createTeamEventInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} eventGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteEvent: async (
			eventGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'eventGuid' is not null or undefined
			assertParamExists('deleteEvent', 'eventGuid', eventGuid)
			const localVarPath = `/teams/events`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (eventGuid !== undefined) {
				localVarQueryParameter['eventGuid'] = eventGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {EditTeamEventInDto} editTeamEventInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		editEvent: async (
			editTeamEventInDto: EditTeamEventInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'editTeamEventInDto' is not null or undefined
			assertParamExists('editEvent', 'editTeamEventInDto', editTeamEventInDto)
			const localVarPath = `/teams/events/edit`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				editTeamEventInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} playlistGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEventByPlaylist: async (
			playlistGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'playlistGuid' is not null or undefined
			assertParamExists('getEventByPlaylist', 'playlistGuid', playlistGuid)
			const localVarPath = `/teams/events/byplaylist`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (playlistGuid !== undefined) {
				localVarQueryParameter['playlistGuid'] = playlistGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEvents: async (
			teamGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'teamGuid' is not null or undefined
			assertParamExists('getEvents', 'teamGuid', teamGuid)
			const localVarPath = `/teams/events`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (teamGuid !== undefined) {
				localVarQueryParameter['teamGuid'] = teamGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * TeamEventsApi - functional programming interface
 * @export
 */
export const TeamEventsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		TeamEventsApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {CreateTeamEventInDto} createTeamEventInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async createEvent(
			createTeamEventInDto: CreateTeamEventInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamEvent>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(
				createTeamEventInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamEventsApi.createEvent']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} eventGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteEvent(
			eventGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamEvent>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEvent(
				eventGuid,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamEventsApi.deleteEvent']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {EditTeamEventInDto} editTeamEventInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async editEvent(
			editTeamEventInDto: EditTeamEventInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamEvent>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.editEvent(
				editTeamEventInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamEventsApi.editEvent']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} playlistGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getEventByPlaylist(
			playlistGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TeamEventData>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getEventByPlaylist(
					playlistGuid,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamEventsApi.getEventByPlaylist']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getEvents(
			teamGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetTeamEventsOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getEvents(
				teamGuid,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamEventsApi.getEvents']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * TeamEventsApi - factory interface
 * @export
 */
export const TeamEventsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = TeamEventsApiFp(configuration)
	return {
		/**
		 *
		 * @param {CreateTeamEventInDto} createTeamEventInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		createEvent(
			createTeamEventInDto: CreateTeamEventInDto,
			options?: any
		): AxiosPromise<TeamEvent> {
			return localVarFp
				.createEvent(createTeamEventInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} eventGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteEvent(eventGuid: string, options?: any): AxiosPromise<TeamEvent> {
			return localVarFp
				.deleteEvent(eventGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {EditTeamEventInDto} editTeamEventInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		editEvent(
			editTeamEventInDto: EditTeamEventInDto,
			options?: any
		): AxiosPromise<TeamEvent> {
			return localVarFp
				.editEvent(editTeamEventInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} playlistGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEventByPlaylist(
			playlistGuid: string,
			options?: any
		): AxiosPromise<TeamEventData> {
			return localVarFp
				.getEventByPlaylist(playlistGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getEvents(
			teamGuid: string,
			options?: any
		): AxiosPromise<GetTeamEventsOutDto> {
			return localVarFp
				.getEvents(teamGuid, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * TeamEventsApi - object-oriented interface
 * @export
 * @class TeamEventsApi
 * @extends {BaseAPI}
 */
export class TeamEventsApi extends BaseAPI {
	/**
	 *
	 * @param {CreateTeamEventInDto} createTeamEventInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamEventsApi
	 */
	public createEvent(
		createTeamEventInDto: CreateTeamEventInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamEventsApiFp(this.configuration)
			.createEvent(createTeamEventInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} eventGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamEventsApi
	 */
	public deleteEvent(eventGuid: string, options?: RawAxiosRequestConfig) {
		return TeamEventsApiFp(this.configuration)
			.deleteEvent(eventGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {EditTeamEventInDto} editTeamEventInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamEventsApi
	 */
	public editEvent(
		editTeamEventInDto: EditTeamEventInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamEventsApiFp(this.configuration)
			.editEvent(editTeamEventInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} playlistGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamEventsApi
	 */
	public getEventByPlaylist(
		playlistGuid: string,
		options?: RawAxiosRequestConfig
	) {
		return TeamEventsApiFp(this.configuration)
			.getEventByPlaylist(playlistGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} teamGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamEventsApi
	 */
	public getEvents(teamGuid: string, options?: RawAxiosRequestConfig) {
		return TeamEventsApiFp(this.configuration)
			.getEvents(teamGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * TeamGettingApi - axios parameter creator
 * @export
 */
export const TeamGettingApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} subdomain
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getAliasBySubdomain: async (
			subdomain: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'subdomain' is not null or undefined
			assertParamExists('getAliasBySubdomain', 'subdomain', subdomain)
			const localVarPath = `/submodules/teams/aliasbysubdomain`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (subdomain !== undefined) {
				localVarQueryParameter['subdomain'] = subdomain
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getAllSubdomains: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/submodules/teams/allsubdomains`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} alias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTeamBasicInfo: async (
			alias: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'alias' is not null or undefined
			assertParamExists('getTeamBasicInfo', 'alias', alias)
			const localVarPath = `/submodules/teams/info`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (alias !== undefined) {
				localVarQueryParameter['alias'] = alias
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTeamPayload: async (
			teamGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'teamGuid' is not null or undefined
			assertParamExists('getTeamPayload', 'teamGuid', teamGuid)
			const localVarPath = `/submodules/teams/teampayload`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (teamGuid !== undefined) {
				localVarQueryParameter['teamGuid'] = teamGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * TeamGettingApi - functional programming interface
 * @export
 */
export const TeamGettingApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		TeamGettingApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {string} subdomain
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getAliasBySubdomain(
			subdomain: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetTeamAliasFromSubdomainOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getAliasBySubdomain(subdomain, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamGettingApi.getAliasBySubdomain']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getAllSubdomains(
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetAllTeamSubdomainAliasesOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getAllSubdomains(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamGettingApi.getAllSubdomains']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} alias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getTeamBasicInfo(
			alias: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetTeamInfoOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getTeamBasicInfo(alias, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamGettingApi.getTeamBasicInfo']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getTeamPayload(
			teamGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamPayload(
				teamGuid,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamGettingApi.getTeamPayload']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * TeamGettingApi - factory interface
 * @export
 */
export const TeamGettingApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = TeamGettingApiFp(configuration)
	return {
		/**
		 *
		 * @param {string} subdomain
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getAliasBySubdomain(
			subdomain: string,
			options?: any
		): AxiosPromise<GetTeamAliasFromSubdomainOutDto> {
			return localVarFp
				.getAliasBySubdomain(subdomain, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getAllSubdomains(
			options?: any
		): AxiosPromise<GetAllTeamSubdomainAliasesOutDto> {
			return localVarFp
				.getAllSubdomains(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} alias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTeamBasicInfo(
			alias: string,
			options?: any
		): AxiosPromise<GetTeamInfoOutDto> {
			return localVarFp
				.getTeamBasicInfo(alias, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTeamPayload(teamGuid: string, options?: any): AxiosPromise<string> {
			return localVarFp
				.getTeamPayload(teamGuid, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * TeamGettingApi - object-oriented interface
 * @export
 * @class TeamGettingApi
 * @extends {BaseAPI}
 */
export class TeamGettingApi extends BaseAPI {
	/**
	 *
	 * @param {string} subdomain
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamGettingApi
	 */
	public getAliasBySubdomain(
		subdomain: string,
		options?: RawAxiosRequestConfig
	) {
		return TeamGettingApiFp(this.configuration)
			.getAliasBySubdomain(subdomain, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamGettingApi
	 */
	public getAllSubdomains(options?: RawAxiosRequestConfig) {
		return TeamGettingApiFp(this.configuration)
			.getAllSubdomains(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} alias
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamGettingApi
	 */
	public getTeamBasicInfo(alias: string, options?: RawAxiosRequestConfig) {
		return TeamGettingApiFp(this.configuration)
			.getTeamBasicInfo(alias, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} teamGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamGettingApi
	 */
	public getTeamPayload(teamGuid: string, options?: RawAxiosRequestConfig) {
		return TeamGettingApiFp(this.configuration)
			.getTeamPayload(teamGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * TeamJoiningApi - axios parameter creator
 * @export
 */
export const TeamJoiningApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {AddTeamMebmerByEmailInDto} addTeamMebmerByEmailInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addByEmail: async (
			addTeamMebmerByEmailInDto: AddTeamMebmerByEmailInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'addTeamMebmerByEmailInDto' is not null or undefined
			assertParamExists(
				'addByEmail',
				'addTeamMebmerByEmailInDto',
				addTeamMebmerByEmailInDto
			)
			const localVarPath = `/submodules/teams/addbyemail`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				addTeamMebmerByEmailInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} teamAlias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getJoinCode: async (
			teamAlias: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'teamAlias' is not null or undefined
			assertParamExists('getJoinCode', 'teamAlias', teamAlias)
			const localVarPath = `/submodules/teams/joincode`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (teamAlias !== undefined) {
				localVarQueryParameter['teamAlias'] = teamAlias
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {JoinTeamInDto} joinTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		joinTeam: async (
			joinTeamInDto: JoinTeamInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'joinTeamInDto' is not null or undefined
			assertParamExists('joinTeam', 'joinTeamInDto', joinTeamInDto)
			const localVarPath = `/submodules/teams/join`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				joinTeamInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * TeamJoiningApi - functional programming interface
 * @export
 */
export const TeamJoiningApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		TeamJoiningApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {AddTeamMebmerByEmailInDto} addTeamMebmerByEmailInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addByEmail(
			addTeamMebmerByEmailInDto: AddTeamMebmerByEmailInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.addByEmail(
				addTeamMebmerByEmailInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamJoiningApi.addByEmail']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} teamAlias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getJoinCode(
			teamAlias: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetJoinCodeOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getJoinCode(
				teamAlias,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamJoiningApi.getJoinCode']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {JoinTeamInDto} joinTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async joinTeam(
			joinTeamInDto: JoinTeamInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JoinTeamOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.joinTeam(
				joinTeamInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamJoiningApi.joinTeam']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * TeamJoiningApi - factory interface
 * @export
 */
export const TeamJoiningApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = TeamJoiningApiFp(configuration)
	return {
		/**
		 *
		 * @param {AddTeamMebmerByEmailInDto} addTeamMebmerByEmailInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addByEmail(
			addTeamMebmerByEmailInDto: AddTeamMebmerByEmailInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.addByEmail(addTeamMebmerByEmailInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} teamAlias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getJoinCode(
			teamAlias: string,
			options?: any
		): AxiosPromise<GetJoinCodeOutDto> {
			return localVarFp
				.getJoinCode(teamAlias, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {JoinTeamInDto} joinTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		joinTeam(
			joinTeamInDto: JoinTeamInDto,
			options?: any
		): AxiosPromise<JoinTeamOutDto> {
			return localVarFp
				.joinTeam(joinTeamInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * TeamJoiningApi - object-oriented interface
 * @export
 * @class TeamJoiningApi
 * @extends {BaseAPI}
 */
export class TeamJoiningApi extends BaseAPI {
	/**
	 *
	 * @param {AddTeamMebmerByEmailInDto} addTeamMebmerByEmailInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamJoiningApi
	 */
	public addByEmail(
		addTeamMebmerByEmailInDto: AddTeamMebmerByEmailInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamJoiningApiFp(this.configuration)
			.addByEmail(addTeamMebmerByEmailInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} teamAlias
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamJoiningApi
	 */
	public getJoinCode(teamAlias: string, options?: RawAxiosRequestConfig) {
		return TeamJoiningApiFp(this.configuration)
			.getJoinCode(teamAlias, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {JoinTeamInDto} joinTeamInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamJoiningApi
	 */
	public joinTeam(
		joinTeamInDto: JoinTeamInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamJoiningApiFp(this.configuration)
			.joinTeam(joinTeamInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * TeamMembersApi - axios parameter creator
 * @export
 */
export const TeamMembersApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} teamAlias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTeamMembers: async (
			teamAlias: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'teamAlias' is not null or undefined
			assertParamExists('getTeamMembers', 'teamAlias', teamAlias)
			const localVarPath = `/submodules/teams/ofteam`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (teamAlias !== undefined) {
				localVarQueryParameter['teamAlias'] = teamAlias
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTeamsOfUser: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/submodules/teams/ofuser`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} teamAlias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		isUserMemberOfTeam: async (
			teamAlias: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'teamAlias' is not null or undefined
			assertParamExists('isUserMemberOfTeam', 'teamAlias', teamAlias)
			const localVarPath = `/submodules/teams/isUserMemberOfTeam`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (teamAlias !== undefined) {
				localVarQueryParameter['teamAlias'] = teamAlias
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {LeaveTeamInDto} leaveTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		leaveTeam: async (
			leaveTeamInDto: LeaveTeamInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'leaveTeamInDto' is not null or undefined
			assertParamExists('leaveTeam', 'leaveTeamInDto', leaveTeamInDto)
			const localVarPath = `/submodules/teams/leaveteam`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				leaveTeamInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {SetMemberRoleInDto} setMemberRoleInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		setMemberRole: async (
			setMemberRoleInDto: SetMemberRoleInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'setMemberRoleInDto' is not null or undefined
			assertParamExists(
				'setMemberRole',
				'setMemberRoleInDto',
				setMemberRoleInDto
			)
			const localVarPath = `/submodules/teams/setrole`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				setMemberRoleInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * TeamMembersApi - functional programming interface
 * @export
 */
export const TeamMembersApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		TeamMembersApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {string} teamAlias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getTeamMembers(
			teamAlias: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetTeamMembersOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamMembers(
				teamAlias,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamMembersApi.getTeamMembers']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getTeamsOfUser(
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetTeamsOfUserOutDto>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getTeamsOfUser(
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamMembersApi.getTeamsOfUser']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} teamAlias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async isUserMemberOfTeam(
			teamAlias: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<IsUserMemberOfTeamOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.isUserMemberOfTeam(teamAlias, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamMembersApi.isUserMemberOfTeam']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {LeaveTeamInDto} leaveTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async leaveTeam(
			leaveTeamInDto: LeaveTeamInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.leaveTeam(
				leaveTeamInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamMembersApi.leaveTeam']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {SetMemberRoleInDto} setMemberRoleInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async setMemberRole(
			setMemberRoleInDto: SetMemberRoleInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.setMemberRole(
				setMemberRoleInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamMembersApi.setMemberRole']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * TeamMembersApi - factory interface
 * @export
 */
export const TeamMembersApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = TeamMembersApiFp(configuration)
	return {
		/**
		 *
		 * @param {string} teamAlias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTeamMembers(
			teamAlias: string,
			options?: any
		): AxiosPromise<GetTeamMembersOutDto> {
			return localVarFp
				.getTeamMembers(teamAlias, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTeamsOfUser(options?: any): AxiosPromise<GetTeamsOfUserOutDto> {
			return localVarFp
				.getTeamsOfUser(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} teamAlias
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		isUserMemberOfTeam(
			teamAlias: string,
			options?: any
		): AxiosPromise<IsUserMemberOfTeamOutDto> {
			return localVarFp
				.isUserMemberOfTeam(teamAlias, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {LeaveTeamInDto} leaveTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		leaveTeam(
			leaveTeamInDto: LeaveTeamInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.leaveTeam(leaveTeamInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {SetMemberRoleInDto} setMemberRoleInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		setMemberRole(
			setMemberRoleInDto: SetMemberRoleInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.setMemberRole(setMemberRoleInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * TeamMembersApi - object-oriented interface
 * @export
 * @class TeamMembersApi
 * @extends {BaseAPI}
 */
export class TeamMembersApi extends BaseAPI {
	/**
	 *
	 * @param {string} teamAlias
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamMembersApi
	 */
	public getTeamMembers(teamAlias: string, options?: RawAxiosRequestConfig) {
		return TeamMembersApiFp(this.configuration)
			.getTeamMembers(teamAlias, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamMembersApi
	 */
	public getTeamsOfUser(options?: RawAxiosRequestConfig) {
		return TeamMembersApiFp(this.configuration)
			.getTeamsOfUser(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} teamAlias
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamMembersApi
	 */
	public isUserMemberOfTeam(
		teamAlias: string,
		options?: RawAxiosRequestConfig
	) {
		return TeamMembersApiFp(this.configuration)
			.isUserMemberOfTeam(teamAlias, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {LeaveTeamInDto} leaveTeamInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamMembersApi
	 */
	public leaveTeam(
		leaveTeamInDto: LeaveTeamInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamMembersApiFp(this.configuration)
			.leaveTeam(leaveTeamInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {SetMemberRoleInDto} setMemberRoleInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamMembersApi
	 */
	public setMemberRole(
		setMemberRoleInDto: SetMemberRoleInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamMembersApiFp(this.configuration)
			.setMemberRole(setMemberRoleInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * TeamPlaylistsApi - axios parameter creator
 * @export
 */
export const TeamPlaylistsApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPinnedPlaylistsToTeam: async (
			teamGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'teamGuid' is not null or undefined
			assertParamExists('getPinnedPlaylistsToTeam', 'teamGuid', teamGuid)
			const localVarPath = `/submodules/teams/playlists/getpinnedplaylists`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (teamGuid !== undefined) {
				localVarQueryParameter['teamGuid'] = teamGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		pinPlaylistToTeam: async (
			pinPlaylistToTeamInDto: PinPlaylistToTeamInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'pinPlaylistToTeamInDto' is not null or undefined
			assertParamExists(
				'pinPlaylistToTeam',
				'pinPlaylistToTeamInDto',
				pinPlaylistToTeamInDto
			)
			const localVarPath = `/submodules/teams/playlists/pinplaylist`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				pinPlaylistToTeamInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		unpinPlaylistFromTeam: async (
			pinPlaylistToTeamInDto: PinPlaylistToTeamInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'pinPlaylistToTeamInDto' is not null or undefined
			assertParamExists(
				'unpinPlaylistFromTeam',
				'pinPlaylistToTeamInDto',
				pinPlaylistToTeamInDto
			)
			const localVarPath = `/submodules/teams/playlists/unpinplaylist`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				pinPlaylistToTeamInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * TeamPlaylistsApi - functional programming interface
 * @export
 */
export const TeamPlaylistsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		TeamPlaylistsApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getPinnedPlaylistsToTeam(
			teamGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetPinnedPlaylistsToTeamOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getPinnedPlaylistsToTeam(
					teamGuid,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamPlaylistsApi.getPinnedPlaylistsToTeam']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async pinPlaylistToTeam(
			pinPlaylistToTeamInDto: PinPlaylistToTeamInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.pinPlaylistToTeam(
					pinPlaylistToTeamInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamPlaylistsApi.pinPlaylistToTeam']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async unpinPlaylistFromTeam(
			pinPlaylistToTeamInDto: PinPlaylistToTeamInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.unpinPlaylistFromTeam(
					pinPlaylistToTeamInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamPlaylistsApi.unpinPlaylistFromTeam']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * TeamPlaylistsApi - factory interface
 * @export
 */
export const TeamPlaylistsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = TeamPlaylistsApiFp(configuration)
	return {
		/**
		 *
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getPinnedPlaylistsToTeam(
			teamGuid: string,
			options?: any
		): AxiosPromise<GetPinnedPlaylistsToTeamOutDto> {
			return localVarFp
				.getPinnedPlaylistsToTeam(teamGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		pinPlaylistToTeam(
			pinPlaylistToTeamInDto: PinPlaylistToTeamInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.pinPlaylistToTeam(pinPlaylistToTeamInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		unpinPlaylistFromTeam(
			pinPlaylistToTeamInDto: PinPlaylistToTeamInDto,
			options?: any
		): AxiosPromise<void> {
			return localVarFp
				.unpinPlaylistFromTeam(pinPlaylistToTeamInDto, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * TeamPlaylistsApi - object-oriented interface
 * @export
 * @class TeamPlaylistsApi
 * @extends {BaseAPI}
 */
export class TeamPlaylistsApi extends BaseAPI {
	/**
	 *
	 * @param {string} teamGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamPlaylistsApi
	 */
	public getPinnedPlaylistsToTeam(
		teamGuid: string,
		options?: RawAxiosRequestConfig
	) {
		return TeamPlaylistsApiFp(this.configuration)
			.getPinnedPlaylistsToTeam(teamGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamPlaylistsApi
	 */
	public pinPlaylistToTeam(
		pinPlaylistToTeamInDto: PinPlaylistToTeamInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamPlaylistsApiFp(this.configuration)
			.pinPlaylistToTeam(pinPlaylistToTeamInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {PinPlaylistToTeamInDto} pinPlaylistToTeamInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamPlaylistsApi
	 */
	public unpinPlaylistFromTeam(
		pinPlaylistToTeamInDto: PinPlaylistToTeamInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamPlaylistsApiFp(this.configuration)
			.unpinPlaylistFromTeam(pinPlaylistToTeamInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * TeamSongNotesApi - axios parameter creator
 * @export
 */
export const TeamSongNotesApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {AddTeamNoteToVariantInDto} addTeamNoteToVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addNoteToVariant: async (
			addTeamNoteToVariantInDto: AddTeamNoteToVariantInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'addTeamNoteToVariantInDto' is not null or undefined
			assertParamExists(
				'addNoteToVariant',
				'addTeamNoteToVariantInDto',
				addTeamNoteToVariantInDto
			)
			const localVarPath = `/team/song/notes/add`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				addTeamNoteToVariantInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {DeleteTeamNoteInDto} deleteTeamNoteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteNote: async (
			deleteTeamNoteInDto: DeleteTeamNoteInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'deleteTeamNoteInDto' is not null or undefined
			assertParamExists(
				'deleteNote',
				'deleteTeamNoteInDto',
				deleteTeamNoteInDto
			)
			const localVarPath = `/team/song/notes`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'DELETE',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				deleteTeamNoteInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {UpdateTeamNoteInDto} updateTeamNoteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		editNote: async (
			updateTeamNoteInDto: UpdateTeamNoteInDto,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'updateTeamNoteInDto' is not null or undefined
			assertParamExists('editNote', 'updateTeamNoteInDto', updateTeamNoteInDto)
			const localVarPath = `/team/song/notes/edit`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			localVarHeaderParameter['Content-Type'] = 'application/json'

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}
			localVarRequestOptions.data = serializeDataIfNeeded(
				updateTeamNoteInDto,
				localVarRequestOptions,
				configuration
			)

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getAllNotesOfTeam: async (
			teamGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'teamGuid' is not null or undefined
			assertParamExists('getAllNotesOfTeam', 'teamGuid', teamGuid)
			const localVarPath = `/team/song/notes/all`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (teamGuid !== undefined) {
				localVarQueryParameter['teamGuid'] = teamGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getNotesOfVariantAndTeam: async (
			packGuid: string,
			teamGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'packGuid' is not null or undefined
			assertParamExists('getNotesOfVariantAndTeam', 'packGuid', packGuid)
			// verify required parameter 'teamGuid' is not null or undefined
			assertParamExists('getNotesOfVariantAndTeam', 'teamGuid', teamGuid)
			const localVarPath = `/team/song/notes`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (packGuid !== undefined) {
				localVarQueryParameter['packGuid'] = packGuid
			}

			if (teamGuid !== undefined) {
				localVarQueryParameter['teamGuid'] = teamGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * TeamSongNotesApi - functional programming interface
 * @export
 */
export const TeamSongNotesApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		TeamSongNotesApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {AddTeamNoteToVariantInDto} addTeamNoteToVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async addNoteToVariant(
			addTeamNoteToVariantInDto: AddTeamNoteToVariantInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.addNoteToVariant(
					addTeamNoteToVariantInDto,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamSongNotesApi.addNoteToVariant']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {DeleteTeamNoteInDto} deleteTeamNoteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async deleteNote(
			deleteTeamNoteInDto: DeleteTeamNoteInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNote(
				deleteTeamNoteInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamSongNotesApi.deleteNote']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {UpdateTeamNoteInDto} updateTeamNoteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async editNote(
			updateTeamNoteInDto: UpdateTeamNoteInDto,
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.editNote(
				updateTeamNoteInDto,
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamSongNotesApi.editNote']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getAllNotesOfTeam(
			teamGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetAllTeamNotesOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getAllNotesOfTeam(teamGuid, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamSongNotesApi.getAllNotesOfTeam']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getNotesOfVariantAndTeam(
			packGuid: string,
			teamGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetNotesOfVariantOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getNotesOfVariantAndTeam(
					packGuid,
					teamGuid,
					options
				)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamSongNotesApi.getNotesOfVariantAndTeam']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * TeamSongNotesApi - factory interface
 * @export
 */
export const TeamSongNotesApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = TeamSongNotesApiFp(configuration)
	return {
		/**
		 *
		 * @param {AddTeamNoteToVariantInDto} addTeamNoteToVariantInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		addNoteToVariant(
			addTeamNoteToVariantInDto: AddTeamNoteToVariantInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.addNoteToVariant(addTeamNoteToVariantInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {DeleteTeamNoteInDto} deleteTeamNoteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		deleteNote(
			deleteTeamNoteInDto: DeleteTeamNoteInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.deleteNote(deleteTeamNoteInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {UpdateTeamNoteInDto} updateTeamNoteInDto
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		editNote(
			updateTeamNoteInDto: UpdateTeamNoteInDto,
			options?: any
		): AxiosPromise<boolean> {
			return localVarFp
				.editNote(updateTeamNoteInDto, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getAllNotesOfTeam(
			teamGuid: string,
			options?: any
		): AxiosPromise<GetAllTeamNotesOutDto> {
			return localVarFp
				.getAllNotesOfTeam(teamGuid, options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {string} packGuid
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getNotesOfVariantAndTeam(
			packGuid: string,
			teamGuid: string,
			options?: any
		): AxiosPromise<GetNotesOfVariantOutDto> {
			return localVarFp
				.getNotesOfVariantAndTeam(packGuid, teamGuid, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * TeamSongNotesApi - object-oriented interface
 * @export
 * @class TeamSongNotesApi
 * @extends {BaseAPI}
 */
export class TeamSongNotesApi extends BaseAPI {
	/**
	 *
	 * @param {AddTeamNoteToVariantInDto} addTeamNoteToVariantInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamSongNotesApi
	 */
	public addNoteToVariant(
		addTeamNoteToVariantInDto: AddTeamNoteToVariantInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamSongNotesApiFp(this.configuration)
			.addNoteToVariant(addTeamNoteToVariantInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {DeleteTeamNoteInDto} deleteTeamNoteInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamSongNotesApi
	 */
	public deleteNote(
		deleteTeamNoteInDto: DeleteTeamNoteInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamSongNotesApiFp(this.configuration)
			.deleteNote(deleteTeamNoteInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {UpdateTeamNoteInDto} updateTeamNoteInDto
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamSongNotesApi
	 */
	public editNote(
		updateTeamNoteInDto: UpdateTeamNoteInDto,
		options?: RawAxiosRequestConfig
	) {
		return TeamSongNotesApiFp(this.configuration)
			.editNote(updateTeamNoteInDto, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} teamGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamSongNotesApi
	 */
	public getAllNotesOfTeam(teamGuid: string, options?: RawAxiosRequestConfig) {
		return TeamSongNotesApiFp(this.configuration)
			.getAllNotesOfTeam(teamGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {string} packGuid
	 * @param {string} teamGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamSongNotesApi
	 */
	public getNotesOfVariantAndTeam(
		packGuid: string,
		teamGuid: string,
		options?: RawAxiosRequestConfig
	) {
		return TeamSongNotesApiFp(this.configuration)
			.getNotesOfVariantAndTeam(packGuid, teamGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * TeamStatisticsApi - axios parameter creator
 * @export
 */
export const TeamStatisticsApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTeamStatistics: async (
			teamGuid: string,
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			// verify required parameter 'teamGuid' is not null or undefined
			assertParamExists('getTeamStatistics', 'teamGuid', teamGuid)
			const localVarPath = `/teams/statistics`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			if (teamGuid !== undefined) {
				localVarQueryParameter['teamGuid'] = teamGuid
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * TeamStatisticsApi - functional programming interface
 * @export
 */
export const TeamStatisticsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator =
		TeamStatisticsApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getTeamStatistics(
			teamGuid: string,
			options?: RawAxiosRequestConfig
		): Promise<
			(
				axios?: AxiosInstance,
				basePath?: string
			) => AxiosPromise<GetTeamStatisticsOutDto>
		> {
			const localVarAxiosArgs =
				await localVarAxiosParamCreator.getTeamStatistics(teamGuid, options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['TeamStatisticsApi.getTeamStatistics']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * TeamStatisticsApi - factory interface
 * @export
 */
export const TeamStatisticsApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = TeamStatisticsApiFp(configuration)
	return {
		/**
		 *
		 * @param {string} teamGuid
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getTeamStatistics(
			teamGuid: string,
			options?: any
		): AxiosPromise<GetTeamStatisticsOutDto> {
			return localVarFp
				.getTeamStatistics(teamGuid, options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * TeamStatisticsApi - object-oriented interface
 * @export
 * @class TeamStatisticsApi
 * @extends {BaseAPI}
 */
export class TeamStatisticsApi extends BaseAPI {
	/**
	 *
	 * @param {string} teamGuid
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof TeamStatisticsApi
	 */
	public getTeamStatistics(teamGuid: string, options?: RawAxiosRequestConfig) {
		return TeamStatisticsApiFp(this.configuration)
			.getTeamStatistics(teamGuid, options)
			.then((request) => request(this.axios, this.basePath))
	}
}

/**
 * WebhookApi - axios parameter creator
 * @export
 */
export const WebhookApiAxiosParamCreator = function (
	configuration?: Configuration
) {
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		webhook: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/webhook`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'POST',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		webhookGet: async (
			options: RawAxiosRequestConfig = {}
		): Promise<RequestArgs> => {
			const localVarPath = `/webhook`
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
			let baseOptions
			if (configuration) {
				baseOptions = configuration.baseOptions
			}

			const localVarRequestOptions = {
				method: 'GET',
				...baseOptions,
				...options,
			}
			const localVarHeaderParameter = {} as any
			const localVarQueryParameter = {} as any

			// authentication bearer required
			// http bearer authentication required
			await setBearerAuthToObject(localVarHeaderParameter, configuration)

			setSearchParams(localVarUrlObj, localVarQueryParameter)
			let headersFromBaseOptions =
				baseOptions && baseOptions.headers ? baseOptions.headers : {}
			localVarRequestOptions.headers = {
				...localVarHeaderParameter,
				...headersFromBaseOptions,
				...options.headers,
			}

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			}
		},
	}
}

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = WebhookApiAxiosParamCreator(configuration)
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async webhook(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.webhook(options)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['WebhookApi.webhook']?.[localVarOperationServerIndex]
					?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async webhookGet(
			options?: RawAxiosRequestConfig
		): Promise<
			(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
		> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.webhookGet(
				options
			)
			const localVarOperationServerIndex = configuration?.serverIndex ?? 0
			const localVarOperationServerBasePath =
				operationServerMap['WebhookApi.webhookGet']?.[
					localVarOperationServerIndex
				]?.url
			return (axios, basePath) =>
				createRequestFunction(
					localVarAxiosArgs,
					globalAxios,
					BASE_PATH,
					configuration
				)(axios, localVarOperationServerBasePath || basePath)
		},
	}
}

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (
	configuration?: Configuration,
	basePath?: string,
	axios?: AxiosInstance
) {
	const localVarFp = WebhookApiFp(configuration)
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		webhook(options?: any): AxiosPromise<void> {
			return localVarFp
				.webhook(options)
				.then((request) => request(axios, basePath))
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		webhookGet(options?: any): AxiosPromise<object> {
			return localVarFp
				.webhookGet(options)
				.then((request) => request(axios, basePath))
		},
	}
}

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI {
	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WebhookApi
	 */
	public webhook(options?: RawAxiosRequestConfig) {
		return WebhookApiFp(this.configuration)
			.webhook(options)
			.then((request) => request(this.axios, this.basePath))
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof WebhookApi
	 */
	public webhookGet(options?: RawAxiosRequestConfig) {
		return WebhookApiFp(this.configuration)
			.webhookGet(options)
			.then((request) => request(this.axios, this.basePath))
	}
}
